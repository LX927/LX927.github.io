<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-jsp第四次课讲义" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/11/13/jsp%E7%AC%AC%E5%9B%9B%E6%AC%A1%E8%AF%BE%E8%AE%B2%E4%B9%89/" class="article-date">
  <time datetime="2019-11-13T06:41:23.000Z" itemprop="datePublished">2019-11-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/13/jsp%E7%AC%AC%E5%9B%9B%E6%AC%A1%E8%AF%BE%E8%AE%B2%E4%B9%89/">jsp第四次课讲义</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>动态网站开发第四次课讲义<br>一、学习目标<br>    1. 会话技术<br>        1. Cookie<br>        2. Session<br>二、具体讲解<br>2.1、会话技术</p>
<ol>
<li>会话：一次会话中包含多次请求和响应。<br>一次会话：浏览器第一次给服务器资源发送请求，会话建立，直到有一方<br>断开为止<ol start="2">
<li>功能：在一次会话的范围内的多次请求间，共享数据</li>
<li>方式：<ol>
<li>客户端会话技术：Cookie</li>
<li>服务器端会话技术：Session</li>
</ol>
</li>
<li>2、Cookie</li>
</ol>
</li>
<li>概念：客户端会话技术，将数据保存到客户端<ol start="2">
<li>快速入门：<br>使用步骤：<ol>
<li>创建Cookie对象，绑定数据<br> new Cookie(String name, String value) </li>
<li>发送Cookie对象<br> response.addCookie(Cookie cookie) </li>
<li>获取Cookie，拿到数据<br> Cookie[]  request.getCookies()  </li>
</ol>
</li>
<li>实现原理<br>基于响应头set-cookie和请求头cookie实现</li>
<li>cookie的细节<ol>
<li>一次可不可以发送多个cookie?<br> 可以<br> 可以创建多个Cookie对象，使用response调用多次addCookie方法发送<br>cookie即可。</li>
<li>cookie在浏览器中保存多长时间？<ol>
<li>默认情况下，当浏览器关闭后，Cookie数据被销毁</li>
<li>持久化存储：<br> setMaxAge(int seconds)</li>
</ol>
</li>
</ol>
</li>
<li>正数：将Cookie数据写到硬盘的文件中。持久化存储。并指<br>定cookie存活时间，时间到后，cookie文件自动失效<pre><code>2. 负数：默认值
3. 零：删除cookie信息</code></pre><ol start="3">
<li>cookie能不能存中文？<pre><code>在tomcat 8 之前 cookie中不能直接存储中文数据。
需要将中文数据转码---一般采用URL编码(%E3)
在tomcat 8 之后，cookie支持中文数据。特殊字符还是不</code></pre>支持，建议使<br>用URL编码存储，URL解码解析</li>
<li>cookie共享问题？<ol>
<li>假设在一个tomcat服务器中，部署了多个web项目，那么在这些web<br>项目中cookie能不能共享？<br>  *默认情况下cookie不能共享<br>  *setPath(String path):设置cookie的获取范围。默认情况下，设置当前的<br>虚拟目录<ul>
<li>如果要共享，则可以将path设置为”/“<ol start="2">
<li>不同的tomcat服务器间cookie共享问题？</li>
</ol>
</li>
<li>setDomain(String path):如果设置一级域名相同，那么多个服务器之<br>间cookie可以共享</li>
<li>setDomain(“.baidu.com”),那么tieba.baidu.com和news.baidu.com<br>中cookie可以共享</li>
</ul>
</li>
</ol>
</li>
<li>Cookie的特点和作用<br>特点：<pre><code>1. cookie存储数据在客户端浏览器
2. 浏览器对于单个cookie 的大小有限制(4kb) 以及 </code></pre>对同一个域名下的总cookie数量也有限制(20个)<br> 作用：<pre><code>1. cookie一般用于存出少量的不太敏感的数据
2. 在不登录的情况下，完成服务器对客户端的</code></pre>身份识别</li>
<li>案例：记住上一次访问时间<ol>
<li>需求：<ol>
<li>访问一个Servlet，如果是第一次访问，则提示：您好，欢迎您首次访问。</li>
<li>如果不是第一次访问，则提示：欢迎回来，您上次访问时间为:显示时<br>间字符串</li>
</ol>
</li>
<li>分析：<ol>
<li>可以采用Cookie来完成</li>
<li>在服务器中的Servlet判断是否有一个名为lastTime的cookie<ol>
<li>有：不是第一次访问<ol>
<li>响应数据：欢迎回来，您上次访问时间为:2018年6月10日11:50:20</li>
<li>写回Cookie：lastTime=2018年6月10日11:50:01</li>
</ol>
</li>
<li>没有：是第一次访问<ol>
<li>响应数据：您好，欢迎您首次访问</li>
<li>写回Cookie：lastTime=2018年6月10日11:50:01</li>
</ol>
</li>
</ol>
</li>
<li>代码实现：</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>2、session</li>
<li>概念：服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服<br>务器端的对象中。HttpSession</li>
<li>快速入门：<ol>
<li>获取HttpSession对象：<br> HttpSession session = request.getSession();</li>
<li>使用HttpSession对象：<br> Object getAttribute(String name)<br> void setAttribute(String name, Object value)<br> void removeAttribute(String name)  </li>
</ol>
</li>
<li>原理:<pre><code>Session的实现是依赖于Cookie的。</code></pre></li>
<li>细节：</li>
<li>当客户端关闭后，服务器不关闭，两次获取session是否为同一个？<pre><code>* 默认情况下。不是。
* 如果需要相同，则可以创建Cookie,键为JSESSIONID，设置最大存活时</code></pre>间，让cookie持久化保存。<pre><code>Cookie c = new Cookie(&quot;JSESSIONID&quot;,session.getId());
c.setMaxAge(60*60);
response.addCookie(c);</code></pre><ol start="2">
<li>客户端不关闭，服务器关闭后，两次获取的session是同一个吗？<ul>
<li>不是同一个，但是要确保数据不丢失。tomcat自动完成以下工作<ul>
<li>session的钝化：<ul>
<li>在服务器正常关闭之前，将session对象系列化到硬盘上</li>
</ul>
</li>
<li>session的活化：<ul>
<li>在服务器启动后，将session文件转化为内存中的session对象即可。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>session什么时候被销毁？<ol>
<li>服务器关闭</li>
<li>session对象调用invalidate() 。</li>
<li>session默认失效时间 30分钟<br> 选择性配置修改     <session-config>
     <session-timeout>30</session-timeout>
 </session-config></li>
</ol>
</li>
<li>session的特点<ol>
<li>session用于存储一次会话的多次请求的数据，存在服务器端</li>
<li>session可以存储任意类型，任意大小的数据<br>session与Cookie的区别：<ol>
<li>session存储数据在服务器端，Cookie在客户端</li>
<li>session没有数据大小限制，Cookie有</li>
<li>session数据安全，Cookie相对于不安全<h2 id="案例：验证码"><a href="#案例：验证码" class="headerlink" title="案例：验证码"></a>案例：验证码</h2></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>案例需求：<ol>
<li>访问带有验证码的登录页面login.jsp</li>
<li>用户输入用户名，密码以及验证码。<ul>
<li>如果用户名和密码输入有误，跳转登录页面，提示:用户名或密码错误</li>
<li>如果验证码输入有误，跳转登录页面，提示：验证码错误</li>
<li>如果全部输入正确，则跳转到主页success.jsp，显示：用户名,欢迎您</li>
</ul>
</li>
</ol>
</li>
<li>分析：</li>
</ol>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/11/13/jsp%E7%AC%AC%E5%9B%9B%E6%AC%A1%E8%AF%BE%E8%AE%B2%E4%B9%89/" data-id="ck2wx3th8000544tf08xq0nv7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-动态网站开发第二次课讲义-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/11/06/%E5%8A%A8%E6%80%81%E7%BD%91%E7%AB%99%E5%BC%80%E5%8F%91%E7%AC%AC%E4%BA%8C%E6%AC%A1%E8%AF%BE%E8%AE%B2%E4%B9%89-1/" class="article-date">
  <time datetime="2019-11-06T11:18:38.000Z" itemprop="datePublished">2019-11-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/06/%E5%8A%A8%E6%80%81%E7%BD%91%E7%AB%99%E5%BC%80%E5%8F%91%E7%AC%AC%E4%BA%8C%E6%AC%A1%E8%AF%BE%E8%AE%B2%E4%B9%89-1/">动态网站开发第二次课讲义 (1)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> 动态网站开发第二次课讲义<br>一、学习目标<br>1、了解tomcat目录结构<br>2、了解java web项目目录结构<br>3、掌握jsp概念<br>4、了解Servlet概念，创建servlet<br>5、掌握Servlet的执行原理和生命周期<br>6、servlet系统结构<br>7、理解HTTP协议及HTTP请求的结构（请求行，头，体）<br>8、熟练掌握使用HttpServeltRequest获取常用的头信息，请求参数，请求参数乱码处理，转发的特点<br>9、熟练掌握登陆案例<br>二、具体讲解<br>2.1、tomcat目录结构详解<br>打开tomcat的解压之后的目录可以看到如下的目录结构：</p>
<p>1、bin：<br>bin目录主要是用来存放tomcat的命令，主要有两大类，一类是以.sh结尾的（linux命令），另一类是以.bat结尾的（windows命令）。可以把命令配置在环境变量里边<br>startup 用来启动tomcat<br>shutdown 用来关闭tomcat<br>修改catalina可以设置tomcat的内存<br>2、webapps：<br>webapps目录用来存放应用程序，当tomcat启动时会去加载webapps目录下的应用程序。可以以文件夹、war包、jar包的形式发布应用。<br>当然，你也可以把应用程序放置在磁盘的任意位置，在配置文件中映射好就行。<br>3、conf<br>conf目录主要是用来存放tomcat的一些配置文件。<br>server.xml可以设置端口号、设置域名或IP、默认加载的项目、请求编码<br>web.xml可以设置tomcat支持的文件类型<br>context.xml可以用来配置数据源之类的<br>tomcat-users.xml用来配置管理tomcat的用户与权限<br>4、lib:<br>lib目录主要用来存放tomcat运行需要加载的jar包。<br>例如，像连接数据库的jdbc的包我们可以加入到lib目录中来。<br>5、logs：<br>logs目录用来存放tomcat在运行过程中产生的日志文件，非常重要的是在控制台输出的日志。（清空不会对tomcat运行带来影响）<br>在windows环境中，控制台的输出日志在catalina.xxxx-xx-xx.log文件中<br>在linux环境中，控制台的输出日志在catalina.out文件中<br>6、temp：<br>temp目录用户存放tomcat在运行过程中产生的临时文件。（清空不会对tomcat运行带来影响<br>7、work:<br>work目录用来存放tomcat在运行时的编译后文件，例如JSP编译后的文件。<br>清空work目录，然后重启tomcat，可以达到清除缓存的作用。<br>2.2、了解java web项目目录结构</p>
<p>web.xml配置文件</p>
<p>项目启动时会加载web.xml配置文件<br>Web.xml文件的作用如下<br>1、指定欢迎页面，例如：</p>
<p>上面的例子指定了几个欢迎页面，显示时按顺序从第一个找起，如果第一个存在，就显示第一个，后面的不起作用。如果第一个不存在，就找第二个，以此类推。<br>2、配置servlet、filter、<br>我们以后创建的servlet与filter需要在web.xml中配置才会生效，至于怎么配置后边的课程讲<br>2.3、掌握jsp概念<br>1、基本概念<br>JSP是运行在服务器端的程序，负责java web项目中的数据展示，以及前后数据的中转与交互<br>JSP页面中，可以写html、css、js代码、java代码、el表达式、jstl标签</p>
<p>分别在jsp里边写对应的代码</p>
<p>由于以后jsp里边不写java代码，就不过多演示了</p>
<p>注意：如何设置jsp的编码格式<br>点击window——–&gt;preferences<br>然后搜索jsp<br>点击JSP Files选择utf-8编码格式</p>
<p>2、jsp的执行流程<br>翻译阶段<br>   当Web容器接收到JSP请求时，首先会对JSP文件进行翻译，将编写好的JSP文件通过JSP容器转换成可识别的Java源代码。<br>编译阶段<br>    将Java源文件编译成可执行的字节码文件<br>执行阶段<br>   经过翻译和编译两个阶段，生成了可执行的二进制字节码文件，此时进入执行阶段。当执行结束后，得到处理请求的结果，把生成的结果页面返回到浏览器客户端显示。</p>
<p>2.4、了解Servlet概念,创建servlet<br>Servlet概念以及作用<br>Java Servlet 是运行在 Web 服务器或应用服务器上的程序，它是作为来自 Web 浏览器的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。<br>   用户在jsp页面上输入数据，可以提交给servlet做处理，java代码读到的数据，可以通过servlet交给jsp页面去展示。这在项目中就充当了，控制与中转的功能。<br>创建servlet</p>
<ol>
<li><p>创建JavaEE项目</p>
</li>
<li><p>定义一个类，实现Servlet接口</p>
</li>
<li><p>实现接口中的抽象方法</p>
</li>
<li><p>配置Servlet<br>在web.xml中配置：</p>
<!--配置Servlet -->
<servlet>
<servlet-name>ServletDemo1</servlet-name>
<servlet-class>com.dzqc.web.servlet.ServletDemo1</servlet-class>
</servlet>
<servlet-mapping>
<servlet-name>ServletDemo1</servlet-name>
<url-pattern>/demo1</url-pattern>
</servlet-mapping></li>
<li><p>5、servlet执行原理</p>
</li>
<li><p>当服务器接受到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资源路径</p>
</li>
<li><p>查找web.xml文件，是否有对应的<url-pattern>标签体内容。</p>
</li>
<li><p>如果有，则在找到对应的<servlet-class>全类名</p>
</li>
<li><p>tomcat会将字节码文件加载进内存，并且创建其对象</p>
</li>
<li><p>调用其方法</p>
</li>
<li><p>6、servlet生命周期</p>
</li>
<li><p>被创建：执行init方法，只执行一次</p>
</li>
<li><p>提供服务：执行service方法，执行多次，servelt核心方法</p>
</li>
<li><p>被销毁：执行destroy方法，只执行一次<br>演示案例如下</p>
</li>
</ol>
<p>2.7、servlet体系结构<br>Servlet有一个子类为GenericServlet，GenericServlet又有一个子类为HttpServlet，在创建servlet时，可以实现Servlet接口，也可以继承GenericServlet类。但在项目中创建Servlet的方式为，继承HttpServlet类。<br>创建的方式如下： new—-》servlet</p>
<p>2.7、理解HTTP协议及HTTP请求的结构（请求行，头，体）<br>我们已经掌握了如何创建Servlet,但Servlet的真正作用为处理用于户的请求，以及对用户的请求做响应，那么我们就要知道会发送哪几种请求，要想理解请求，就要先知道Http协议与Http请求结构<br>HTTP协议概念<br>Hyper Text Transfer Protocol 超文本传输协议，定义了，客户端和服务器端通信时，发送数据的格式<br>特点：</p>
<ol>
<li>基于TCP/IP的高级协议</li>
<li>默认端口号:80</li>
<li>基于请求/响应模型的:一次请求对应一次响应</li>
<li>无状态的：每次请求之间相互独立，不能交互数据<br>历史版本：</li>
<li>0：每一次请求响应都会建立新的连接</li>
<li>1：复用连接<br>HTTP协议的请求行，请求头，请求体</li>
<li>请求行<br>请求行包含的内容如下：<br>   请求方式   请求url      请求协议/版本<pre><code>GET     /login.html       HTTP/1.1</code></pre>请求方式：<pre><code>HTTP协议有7中请求方式，常用的有2种
  GET：
    1. 请求参数在请求行中，在url后。
    2. 请求的url长度有限制的
    3. 不太安全
  POST：
    1. 请求参数在请求体中
    2. 请求的url长度没有限制的
    3. 相对安全</code></pre>2、Http协议请求头：<br>请求头的主要作用为：客户端浏览器告诉服务器一些信息<br>1、浏览器告诉服务器，我访问你使用的浏览器版本信息<br>2、告诉服4务器，我(当前请求)从哪里来？<br>3、Http协议请求体：<br>封装POST请求消息的请求参数的，换句话说请求体里放的是要提交给服务器的内容，例如账户名、密码。<br>总结一下：<br>通过以上的学习，就知道我们发送请求时，第一要确定请求方式，是post请求或get请求。第二要知道我们的所传递的内容是在请求中放的。</li>
<li>8、熟练掌握使用HttpServeltRequest获取常用的头信息，请求参数，请求参数乱码处理，转发的特点<br>当用户发送请求时，服务器会创建两个对象，一个是HttpServeltRequest类的请求对象，一个HttpServletResponse类的响应对象。<br>1、request对象和response对象的原理<ol>
<li>request和response对象是由服务器创建的。我们来使用它们</li>
<li>request对象是来获取请求消息，response对象是来设置响应消息<br>首先学习request对象<br>2、request对象继承体系结构：<br> ServletRequest        –    接口<pre><code>|    继承</code></pre> HttpServletRequest    – 接口<pre><code>|    实现</code></pre> org.apache.catalina.connector.RequestFacade 类(tomcat)<br>3、request功能：<br>1、获取请求消息数据<ol>
<li>获取请求行数据<br>GET  /day14/demo1?name=zhangsan  HTTP/1.1<br>方法：<ol>
<li>获取请求方式 ：GET<br> String getMethod()  </li>
<li>获取虚拟目录：/day14<br> String getContextPath()</li>
<li>获取Servlet路径: /demo1<br> String getServletPath()</li>
<li>获取get方式请求参数：name=zhangsan<br> String getQueryString()</li>
<li>获取请求URI：/day14/demo1<br> String getRequestURI():        /day14/demo1<br> StringBuffer getRequestURL()  :<a href="http://localhost/day14/demo1" target="_blank" rel="noopener">http://localhost/day14/demo1</a><br>URL：统一资源定位符 ： <a href="http://localhost/day14/demo1" target="_blank" rel="noopener">http://localhost/day14/demo1</a><br> URI：统一资源标识符 : /day14/demo1                        </li>
<li>获取协议及版本：HTTP/1.1<br> String getProtocol()</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>获取客户机的IP地址：<pre><code>String getRemoteAddr()</code></pre></li>
<li>获取请求头数据<pre><code>  方法：
    String getHeader(String name):通过请求头的名称获取请求头的值
    Enumeration&lt;String&gt; getHeaderNames():获取所有的请求头名称
3.获取请求体数据:
  请求体：只有POST请求方式，才有请求体
   步骤：
     1. 获取流对象
        BufferedReader getReader()：获取字符输入流，只能操作字符数据
        ServletInputStream getInputStream()：获取字节输入流
                                         在文件上传知识点后讲解</code></pre></li>
<li>再从流对象中拿数据<br>2、其它功能（重要）<br>1、获取请求参数通用方式：不论get还是post请求方式都可以使用下列方法来获取请求参数<br> 1.String getParameter(String name):根据参数名称获取参数值<ol start="2">
<li>String[] getParameterValues(String name):根据参数名称获取参数值的数  组</li>
<li>Enumeration<String> getParameterNames():获取所有请求的参数名称</li>
<li>Map&lt;String,String[]&gt; getParameterMap():获取所有参数的map集合<br>中文乱码问题：<br> get方式：tomcat 8 已经将get方式乱码问题解决了<br> post方式：会乱码<br>解决：在获取参数前，设置request的编码request.setCharacterEncoding(“utf-8”);<br>2、请求转发：一种在服务器内部的资源跳转方式<br>1、步骤：</li>
</ol>
</li>
<li>通过request对象获取请求转发器对象：<br>RequestDispatcher getRequestDispatcher(String path)</li>
<li>使用RequestDispatcher对象来进行转发：<br>forward(ServletRequest request, ServletResponse response)<br>  2、特点：<pre><code>1. 浏览器地址栏路径不发生变化
2. 只能转发到当前服务器内部资源中。
3. 转发是一次请求</code></pre>3、共享数据：<pre><code>域对象：一个有作用范围的对象，可以在范围内共享数据
request域：代表一次请求的范围，一般用于请求转发的多个资源中共享数据
  方法：
     1. void setAttribute(String name,Object obj):存储数据
     2. Object getAttitude(String name):通过键获取值
     3. void removeAttribute(String name):通过键移除键值对</code></pre></li>
<li>获取ServletContext：<pre><code>ServletContext getServletContext()</code></pre>讲解案例：</li>
</ol>
<p>2.9、熟练掌握登陆案例</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/11/06/%E5%8A%A8%E6%80%81%E7%BD%91%E7%AB%99%E5%BC%80%E5%8F%91%E7%AC%AC%E4%BA%8C%E6%AC%A1%E8%AF%BE%E8%AE%B2%E4%B9%89-1/" data-id="ck2wx3thh000644tf6uot0s5k" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-动态网站开发第三次课讲义" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/11/06/%E5%8A%A8%E6%80%81%E7%BD%91%E7%AB%99%E5%BC%80%E5%8F%91%E7%AC%AC%E4%B8%89%E6%AC%A1%E8%AF%BE%E8%AE%B2%E4%B9%89/" class="article-date">
  <time datetime="2019-11-06T10:49:20.000Z" itemprop="datePublished">2019-11-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/06/%E5%8A%A8%E6%80%81%E7%BD%91%E7%AB%99%E5%BC%80%E5%8F%91%E7%AC%AC%E4%B8%89%E6%AC%A1%E8%AF%BE%E8%AE%B2%E4%B9%89/">动态网站开发第三次课讲义</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>动态网站开发第三次课讲义<br>一、学习目标<br>1、掌握http协议之响应部分<br>2、熟练掌握Response的相关 API （重定向，路径，输出流）<br>3、掌握ServletContext的常用API<br>4、完成文件下载案例<br>二、具体讲解<br>   2.1、掌握http协议之响应部分</p>
<ol>
<li>请求消息：客户端发送给服务器端的数据<br> 数据格式：<pre><code>1. 请求行
2. 请求头
3. 请求空行
4. 请求体</code></pre><ol start="2">
<li>响应消息：服务器端发送给客户端的数据<br>数据格式：<ol>
<li>响应行<ol>
<li>组成：协议/版本 响应状态码 状态码描述</li>
<li>响应状态码：服务器告诉客户端浏览器本次请求和响应的一个状态。<ol>
<li>状态码都是3位数字 </li>
<li>分类：</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>1xx：服务器就收客户端消息，但没有接受完成，等待一段时       间后，发送1xx多状态码<pre><code>2. 2xx：成功。代表：200
3. 3xx：重定向。代表：302(重定向)，304(访问缓存)
4. 4xx：客户端错误。
    代表：
        404（请求路径没有对应的资源） 
        405：请求方式没有对应的doXxx方法
5. 5xx：服务器端错误。代表：500(服务器内部出现异常)        </code></pre><ol start="2">
<li>响应头：<ol>
<li>格式：头名称： 值</li>
<li>常见的响应头：<ol>
<li>Content-Type：服务器告诉客户端本次响应体数据格式以及编码格式</li>
<li>Content-disposition：服务器告诉客户端以什么格式打开响应体数据<br>MIME类型<br>值：<br>  in-line:默认值,在当前页面内打开<br>  attachment;filename=xxx：以附件形式打开响应体。文件下载</li>
</ol>
</li>
</ol>
</li>
<li>响应空行</li>
<li>响应体:传输的数据<br>响应字符串格式<br>HTTP/1.1 200 OK<br>Content-Type: text/html;charset=UTF-8<br>Content-Length: 101<br>Date: Wed, 06 Jun 2018 07:08:42 GMT<html>
<head>
 <title>$Title$</title>
</head>
<body>
hello , response
</body>
</html>

</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>2.2、熟练掌握Response的相关 API （重定向，路径，输出流）<br>    Response对象<br>       功能：设置响应消息<br>        1. 设置响应行<br>            1. 格式：HTTP/1.1 200 ok<br>            2. 设置状态码：setStatus(int sc)<br>        2. 设置响应头：setHeader(String name, String value)<br>        3. 设置响应体：<br>            使用步骤：<br>                1. 获取输出流<br>                    字符输出流：PrintWriter getWriter()<br>                    字节输出流：ServletOutputStream getOutputStream()<br>                2. 使用输出流，将数据输出到客户端浏览器<br>    案例：<br>        1. 完成重定向<br>            重定向：资源跳转的方式，重定向为向另外一个servlet<br>                    或另外一个jsp发送一个新的请求<br>            代码实现：<br>              1. 设置状态码为302<br>                response.setStatus(302);<br>              2.设置响应头location<br>                response.setHeader(“location”,”/day15/responseDemo2”);<br>                //简单的重定向方法<br>                response.sendRedirect(“/day15/responseDemo2”);<br>             重定向的特点:redirect<br>                1. 地址栏发生变化<br>                2. 重定向可以访问其他站点(服务器)的资源<br>                3. 重定向是两次请求。不能使用request对象来共享数据<br>             转发的特点：forward<br>                1. 转发地址栏路径不变<br>                2. 转发只能访问当前服务器下的资源<br>                3. 转发是一次请求，可以使用request对象来共享数据<br>             forward 和  redirect 区别<br>              路径写法：<br>                1. 路径分类<br>                    1. 相对路径：通过相对路径不可以确定唯一资源<br>                        如：./index.html<br>                          不以/开头，以.开头路径<br>                          规则：找到当前资源和目标资源之间的相对位置关系<br>                            ./：当前目录<br>                            ../:后退一级目录<br>                    2. 绝对路径：通过绝对路径可以确定唯一资源<br>    如：<a href="http://localhost/day15/responseDemo2" target="_blank" rel="noopener">http://localhost/day15/responseDemo2</a>             /day15/responseDemo2     以/开头的路径<br>规则：判断定义的路径是给谁用的？判断请求将来从哪儿发出<br>                         给客户端浏览器使用：需要加虚拟目录(项目的访问路径)<br>                                建议虚拟目录动态获取：request.getContextPath()<br>                                <a> , <form> 重定向…<br>                         给服务器使用：不需要加虚拟目录<br>                                转发路径<br>        2. 服务器输出字符数据到浏览器<br>             步骤：<br>                1. 获取字符输出流<br>                2. 输出数据<br>             注意：<br>                乱码问题：<br>                  1. PrintWriter pw = response.getWriter();获取的流的默认编码是ISO-8859-1<br>              2. 设置该流的默认编码<br>              //简单的形式，设置编码，是在获取流之前设置<br>                 response.setContentType(“text/html;charset=utf-8”);<br>        3. 服务器输出字节数据到浏览器<br>            步骤：<br>                1. 获取字节输出流<br>                2. 输出数据<br>        4. 验证码<br>            1. 本质：图片<br>            2. 目的：防止恶意表单注册</p>
<p>2.3、掌握ServletContext的常用API<br>Servlet有四大域对象，pageContext request session application<br>request       HttpServletRequest<br>session       HttpSession<br>application    ServletContext</p>
<ol>
<li>概念：代表整个web应用，可以和程序的容器(服务器)来通信<ol start="2">
<li>获取：<ol>
<li>通过request对象获取<br> request.getServletContext();</li>
<li>通过HttpServlet获取<br> this.getServletContext();</li>
</ol>
</li>
<li>功能：<ol>
<li>获取MIME类型：<ul>
<li>MIME类型:在互联网通信过程中定义的一种文件数据类型<ul>
<li>格式： 大类型/小类型   text/html        image/jpeg</li>
</ul>
</li>
<li>获取：String getMimeType(String file)  </li>
</ul>
</li>
<li>域对象：共享数据<ol>
<li>setAttribute(String name,Object value)</li>
<li>getAttribute(String name)</li>
<li>removeAttribute(String name)</li>
</ol>
<ul>
<li>ServletContext对象范围：所有用户所有请求的数据</li>
</ul>
</li>
<li>获取文件的真实(服务器)路径<ol>
<li>方法：String getRealPath(String path)<br>String b = context.getRealPath(“/b.txt”);//web目录下资源访问<br>System.out.println(b);<br>String c = context.getRealPath(“/WEB-INF/c.txt”);//WEB-INF目录下的资源访问<br>System.out.println(c);<br>String a = context.getRealPath(“/WEB-INF/classes/a.txt”);//src目录下的资源访问<br>System.out.println(a);</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>4、完成文件下载案例<pre><code>文件下载需求：
  1. 页面显示超链接
  2. 点击超链接后弹出下载提示框
  3. 完成图片文件下载
分析：
  1. 超链接指向的资源如果能够被浏览器解析，则在浏览器中展示，如果不能解析，则弹出下载提示框。不满足需求
  2. 任何资源都必须弹出下载提示框
  3. 使用响应头设置资源的打开方式：
   content-disposition:attachment;filename=xxx
步骤：
  1. 定义页面，编辑超链接href属性，指向Servlet，传递资源名称filename
  2. 定义Servlet
      1. 获取文件名称
      2. 使用字节输入流加载文件进内存
      3. 指定response的响应头： content-disposition:attachment;filename=xxx
      4. 将数据写出到response输出流
问题：
    中文文件问题
       解决思路：
          1. 获取客户端使用的浏览器版本信息
          2. 根据不同的版本信息，设置filename的编码方式不同</code></pre></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/11/06/%E5%8A%A8%E6%80%81%E7%BD%91%E7%AB%99%E5%BC%80%E5%8F%91%E7%AC%AC%E4%B8%89%E6%AC%A1%E8%AF%BE%E8%AE%B2%E4%B9%89/" data-id="ck2wx3th2000244tf4b1d0u4n" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-xml笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/10/24/xml%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2019-10-24T01:39:31.000Z" itemprop="datePublished">2019-10-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/10/24/xml%E7%AC%94%E8%AE%B0/">xml笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="今日内容"><a href="#今日内容" class="headerlink" title="今日内容"></a>今日内容</h1><pre><code>1. XML
    1. 概念
    2. 语法
    3. 解析</code></pre><h2 id="XML："><a href="#XML：" class="headerlink" title="XML："></a>XML：</h2><pre><code>1. 概念：Extensible Markup Language 可扩展标记语言
    * 可扩展：标签都是自定义的。 &lt;user&gt;  &lt;student&gt;

    * 功能
        * 存储数据
            1. 配置文件
            2. 在网络中传输
    * xml与html的区别
        1. xml标签都是自定义的，html标签是预定义。
        2. xml的语法严格，html语法松散
        3. xml是存储数据的，html是展示数据

    * w3c:万维网联盟

2. 语法：
    * 基本语法：
        1. xml文档的后缀名 .xml
        2. xml第一行必须定义为文档声明
        3. xml文档中有且仅有一个根标签
        4. 属性值必须使用引号(单双都可)引起来
        5. 标签必须正确关闭
        6. xml标签名称区分大小写
    * 快速入门：
        &lt;?xml version=&apos;1.0&apos; ?&gt;
        &lt;users&gt;
            &lt;user id=&apos;1&apos;&gt;
                &lt;name&gt;zhangsan&lt;/name&gt;
                &lt;age&gt;23&lt;/age&gt;
                &lt;gender&gt;male&lt;/gender&gt;
                &lt;br/&gt;
            &lt;/user&gt;

            &lt;user id=&apos;2&apos;&gt;
                &lt;name&gt;lisi&lt;/name&gt;
                &lt;age&gt;24&lt;/age&gt;
                &lt;gender&gt;female&lt;/gender&gt;
            &lt;/user&gt;
        &lt;/users&gt;

    * 组成部分：
        1. 文档声明
            1. 格式：&lt;?xml 属性列表 ?&gt;
            2. 属性列表：
                * version：版本号，必须的属性
                * encoding：编码方式。告知解析引擎当前文档使用的字符集，默认值：ISO-8859-1
                * standalone：是否独立
                    * 取值：
                        * yes：不依赖其他文件
                        * no：依赖其他文件
        2. 指令(了解)：结合css的
            * &lt;?xml-stylesheet type=&quot;text/css&quot; href=&quot;a.css&quot; ?&gt;
        3. 标签：标签名称自定义的
            * 规则：
                * 名称可以包含字母、数字以及其他的字符 
                * 名称不能以数字或者标点符号开始 
                * 名称不能以字母 xml（或者 XML、Xml 等等）开始 
                * 名称不能包含空格 

        4. 属性：
            id属性值唯一
        5. 文本：
            * CDATA区：在该区域中的数据会被原样展示
                * 格式：  &lt;![CDATA[ 数据 ]]&gt;


    * 约束：规定xml文档的书写规则
        * 作为框架的使用者(程序员)：
            1. 能够在xml中引入约束文档
            2. 能够简单的读懂约束文档

        * 分类：
            1. DTD:一种简单的约束技术
            2. Schema:一种复杂的约束技术


        * DTD：
            * 引入dtd文档到xml文档中
                * 内部dtd：将约束规则定义在xml文档中
                * 外部dtd：将约束的规则定义在外部的dtd文件中
                    * 本地：&lt;!DOCTYPE 根标签名 SYSTEM &quot;dtd文件的位置&quot;&gt;
                    * 网络：&lt;!DOCTYPE 根标签名 PUBLIC &quot;dtd文件名字&quot; &quot;dtd文件的位置URL&quot;&gt;


        * Schema:
            * 引入：
                1.填写xml文档的根元素
                2.引入xsi前缀.  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
                3.引入xsd文件命名空间.  xsi:schemaLocation=&quot;http://www.itcast.cn/xml  student.xsd&quot;
                4.为每一个xsd约束声明一个前缀,作为标识  xmlns=&quot;http://www.itcast.cn/xml&quot; 

            &lt;students   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
                xmlns=&quot;http://www.itcast.cn/xml&quot;
                xsi:schemaLocation=&quot;http://www.itcast.cn/xml  student.xsd&quot;&gt;



3. 解析：操作xml文档，将文档中的数据读取到内存中
    * 操作xml文档
        1. 解析(读取)：将文档中的数据读取到内存中
        2. 写入：将内存中的数据保存到xml文档中。持久化的存储

    * 解析xml的方式：
        1. DOM：将标记语言文档一次性加载进内存，在内存中形成一颗dom树
            * 优点：操作方便，可以对文档进行CRUD的所有操作
            * 缺点：占内存
        2. SAX：逐行读取，基于事件驱动的。
            * 优点：不占内存。
            * 缺点：只能读取，不能增删改



    * xml常见的解析器：
        1. JAXP：sun公司提供的解析器，支持dom和sax两种思想
        2. DOM4J：一款非常优秀的解析器
        3. Jsoup：jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。
        4. PULL：Android操作系统内置的解析器，sax方式的。


    * Jsoup：jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。
        * 快速入门：
            * 步骤：
                1. 导入jar包
                2. 获取Document对象
                3. 获取对应的标签Element对象
                4. 获取数据

        * 代码：
             //2.1获取student.xml的path
            String path = JsoupDemo1.class.getClassLoader().getResource(&quot;student.xml&quot;).getPath();
            //2.2解析xml文档，加载文档进内存，获取dom树---&gt;Document
            Document document = Jsoup.parse(new File(path), &quot;utf-8&quot;);
            //3.获取元素对象 Element
            Elements elements = document.getElementsByTag(&quot;name&quot;);

            System.out.println(elements.size());
            //3.1获取第一个name的Element对象
            Element element = elements.get(0);
            //3.2获取数据
            String name = element.text();
            System.out.println(name);

    * 对象的使用：
        1. Jsoup：工具类，可以解析html或xml文档，返回Document
            * parse：解析html或xml文档，返回Document
                * parse​(File in, String charsetName)：解析xml或html文件的。
                * parse​(String html)：解析xml或html字符串
                * parse​(URL url, int timeoutMillis)：通过网络路径获取指定的html或xml的文档对象
        2. Document：文档对象。代表内存中的dom树
            * 获取Element对象
                * getElementById​(String id)：根据id属性值获取唯一的element对象
                * getElementsByTag​(String tagName)：根据标签名称获取元素对象集合
                * getElementsByAttribute​(String key)：根据属性名称获取元素对象集合
                * getElementsByAttributeValue​(String key, String value)：根据对应的属性名和属性值获取元素对象集合
        3. Elements：元素Element对象的集合。可以当做 ArrayList&lt;Element&gt;来使用
        4. Element：元素对象
            1. 获取子元素对象
                * getElementById​(String id)：根据id属性值获取唯一的element对象
                * getElementsByTag​(String tagName)：根据标签名称获取元素对象集合
                * getElementsByAttribute​(String key)：根据属性名称获取元素对象集合
                * getElementsByAttributeValue​(String key, String value)：根据对应的属性名和属性值获取元素对象集合

            2. 获取属性值
                * String attr(String key)：根据属性名称获取属性值
            3. 获取文本内容
                * String text():获取文本内容
                * String html():获取标签体的所有内容(包括字标签的字符串内容)
        5. Node：节点对象
            * 是Document和Element的父类


    * 快捷查询方式：
        1. selector:选择器
            * 使用的方法：Elements    select​(String cssQuery)
                * 语法：参考Selector类中定义的语法
        2. XPath：XPath即为XML路径语言，它是一种用来确定XML（标准通用标记语言的子集）文档中某部分位置的语言
            * 使用Jsoup的Xpath需要额外导入jar包。
            * 查询w3cshool参考手册，使用xpath的语法完成查询
            * 代码：
                //1.获取student.xml的path
                String path = JsoupDemo6.class.getClassLoader().getResource(&quot;student.xml&quot;).getPath();
                //2.获取Document对象
                Document document = Jsoup.parse(new File(path), &quot;utf-8&quot;);

                //3.根据document对象，创建JXDocument对象
                JXDocument jxDocument = new JXDocument(document);

                //4.结合xpath语法查询
                //4.1查询所有student标签
                List&lt;JXNode&gt; jxNodes = jxDocument.selN(&quot;//student&quot;);
                for (JXNode jxNode : jxNodes) {
                    System.out.println(jxNode);
                }

                System.out.println(&quot;--------------------&quot;);

                //4.2查询所有student标签下的name标签
                List&lt;JXNode&gt; jxNodes2 = jxDocument.selN(&quot;//student/name&quot;);
                for (JXNode jxNode : jxNodes2) {
                    System.out.println(jxNode);
                }

                System.out.println(&quot;--------------------&quot;);

                //4.3查询student标签下带有id属性的name标签
                List&lt;JXNode&gt; jxNodes3 = jxDocument.selN(&quot;//student/name[@id]&quot;);
                for (JXNode jxNode : jxNodes3) {
                    System.out.println(jxNode);
                }
                System.out.println(&quot;--------------------&quot;);
                //4.4查询student标签下带有id属性的name标签 并且id属性值为itcast

                List&lt;JXNode&gt; jxNodes4 = jxDocument.selN(&quot;//student/name[@id=&apos;itcast&apos;]&quot;);
                for (JXNode jxNode : jxNodes4) {
                    System.out.println(jxNode);
                }</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/10/24/xml%E7%AC%94%E8%AE%B0/" data-id="ck2wx3th6000444tf1r9agtxu" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-jdbc笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/10/23/jdbc%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2019-10-23T11:17:47.000Z" itemprop="datePublished">2019-10-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/10/23/jdbc%E7%AC%94%E8%AE%B0/">jdbc笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="今日内容"><a href="#今日内容" class="headerlink" title="今日内容"></a>今日内容</h1><pre><code>1. JDBC基本概念
2. 快速入门
3. 对JDBC中各个接口和类详解</code></pre><h2 id="JDBC："><a href="#JDBC：" class="headerlink" title="JDBC："></a>JDBC：</h2><pre><code>1. 概念：Java DataBase Connectivity  Java 数据库连接， Java语言操作数据库
    * JDBC本质：其实是官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类。

2. 快速入门：
    * 步骤：
        1. 导入驱动jar包 mysql-connector-java-5.1.37-bin.jar
            1.复制mysql-connector-java-5.1.37-bin.jar到项目的libs目录下
            2.右键--&gt;Add As Library
        2. 注册驱动
        3. 获取数据库连接对象 Connection
        4. 定义sql
        5. 获取执行sql语句的对象 Statement
        6. 执行sql，接受返回结果
        7. 处理结果
        8. 释放资源

    * 代码实现：
          //1. 导入驱动jar包
        //2.注册驱动
        Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
        //3.获取数据库连接对象
        Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/db3&quot;, &quot;root&quot;, &quot;root&quot;);
        //4.定义sql语句
        String sql = &quot;update account set balance = 500 where id = 1&quot;;
        //5.获取执行sql的对象 Statement
        Statement stmt = conn.createStatement();
        //6.执行sql
        int count = stmt.executeUpdate(sql);
        //7.处理结果
        System.out.println(count);
        //8.释放资源
        stmt.close();
        conn.close();

3. 详解各个对象：
    1. DriverManager：驱动管理对象
        * 功能：
            1. 注册驱动：告诉程序该使用哪一个数据库驱动jar
                static void registerDriver(Driver driver) :注册与给定的驱动程序 DriverManager 。 
                写代码使用：  Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
                通过查看源码发现：在com.mysql.jdbc.Driver类中存在静态代码块
                 static {
                        try {
                            java.sql.DriverManager.registerDriver(new Driver());
                        } catch (SQLException E) {
                            throw new RuntimeException(&quot;Can&apos;t register driver!&quot;);
                        }
                    }

                注意：mysql5之后的驱动jar包可以省略注册驱动的步骤。
            2. 获取数据库连接：
                * 方法：static Connection getConnection(String url, String user, String password) 
                * 参数：
                    * url：指定连接的路径
                        * 语法：jdbc:mysql://ip地址(域名):端口号/数据库名称
                        * 例子：jdbc:mysql://localhost:3306/db3
                        * 细节：如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则url可以简写为：jdbc:mysql:///数据库名称
                    * user：用户名
                    * password：密码 
    2. Connection：数据库连接对象
        1. 功能：
            1. 获取执行sql 的对象
                * Statement createStatement()
                * PreparedStatement prepareStatement(String sql)  
            2. 管理事务：
                * 开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务
                * 提交事务：commit() 
                * 回滚事务：rollback() 
    3. Statement：执行sql的对象
        1. 执行sql
            1. boolean execute(String sql) ：可以执行任意的sql 了解 
            2. int executeUpdate(String sql) ：执行DML（insert、update、delete）语句、DDL(create，alter、drop)语句
                * 返回值：影响的行数，可以通过这个影响的行数判断DML语句是否执行成功 返回值&gt;0的则执行成功，反之，则失败。
            3. ResultSet executeQuery(String sql)  ：执行DQL（select)语句
        2. 练习：
            1. account表 添加一条记录
            2. account表 修改记录
            3. account表 删除一条记录

            代码：
                Statement stmt = null;
                Connection conn = null;
                try {
                    //1. 注册驱动
                    Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
                    //2. 定义sql
                    String sql = &quot;insert into account values(null,&apos;王五&apos;,3000)&quot;;
                    //3.获取Connection对象
                    conn = DriverManager.getConnection(&quot;jdbc:mysql:///db3&quot;, &quot;root&quot;, &quot;root&quot;);
                    //4.获取执行sql的对象 Statement
                    stmt = conn.createStatement();
                    //5.执行sql
                    int count = stmt.executeUpdate(sql);//影响的行数
                    //6.处理结果
                    System.out.println(count);
                    if(count &gt; 0){
                        System.out.println(&quot;添加成功！&quot;);
                    }else{
                        System.out.println(&quot;添加失败！&quot;);
                    }

                } catch (ClassNotFoundException e) {
                    e.printStackTrace();
                } catch (SQLException e) {
                    e.printStackTrace();
                }finally {
                    //stmt.close();
                    //7. 释放资源
                    //避免空指针异常
                    if(stmt != null){
                        try {
                            stmt.close();
                        } catch (SQLException e) {
                            e.printStackTrace();
                        }
                    }

                    if(conn != null){
                        try {
                            conn.close();
                        } catch (SQLException e) {
                            e.printStackTrace();
                        }
                    }
                }

    4. ResultSet：结果集对象,封装查询结果
        * boolean next(): 游标向下移动一行，判断当前行是否是最后一行末尾(是否有数据)，如果是，则返回false，如果不是则返回true
        * getXxx(参数):获取数据
            * Xxx：代表数据类型   如： int getInt() ,    String getString()
            * 参数：
                1. int：代表列的编号,从1开始   如： getString(1)
                2. String：代表列名称。 如： getDouble(&quot;balance&quot;)

        * 注意：
            * 使用步骤：
                1. 游标向下移动一行
                2. 判断是否有数据
                3. 获取数据

               //循环判断游标是否是最后一行末尾。
                while(rs.next()){
                    //获取数据
                    //6.2 获取数据
                    int id = rs.getInt(1);
                    String name = rs.getString(&quot;name&quot;);
                    double balance = rs.getDouble(3);

                    System.out.println(id + &quot;---&quot; + name + &quot;---&quot; + balance);
                }

        * 练习：
            * 定义一个方法，查询emp表的数据将其封装为对象，然后装载集合，返回。
                1. 定义Emp类
                2. 定义方法 public List&lt;Emp&gt; findAll(){}
                3. 实现方法 select * from emp;

    5. PreparedStatement：执行sql的对象
        1. SQL注入问题：在拼接sql时，有一些sql的特殊关键字参与字符串的拼接。会造成安全性问题
            1. 输入用户随便，输入密码：a&apos; or &apos;a&apos; = &apos;a
            2. sql：select * from user where username = &apos;fhdsjkf&apos; and password = &apos;a&apos; or &apos;a&apos; = &apos;a&apos; 

        2. 解决sql注入问题：使用PreparedStatement对象来解决
        3. 预编译的SQL：参数使用?作为占位符
        4. 步骤：
            1. 导入驱动jar包 mysql-connector-java-5.1.37-bin.jar
            2. 注册驱动
            3. 获取数据库连接对象 Connection
            4. 定义sql
                * 注意：sql的参数使用？作为占位符。 如：select * from user where username = ? and password = ?;
            5. 获取执行sql语句的对象 PreparedStatement  Connection.prepareStatement(String sql) 
            6. 给？赋值：
                * 方法： setXxx(参数1,参数2)
                    * 参数1：？的位置编号 从1 开始
                    * 参数2：？的值
            7. 执行sql，接受返回结果，不需要传递sql语句
            8. 处理结果
            9. 释放资源

        5. 注意：后期都会使用PreparedStatement来完成增删改查的所有操作
            1. 可以防止SQL注入
            2. 效率更高</code></pre><h2 id="抽取JDBC工具类-：-JDBCUtils"><a href="#抽取JDBC工具类-：-JDBCUtils" class="headerlink" title="抽取JDBC工具类 ： JDBCUtils"></a>抽取JDBC工具类 ： JDBCUtils</h2><pre><code>* 目的：简化书写
* 分析：
    1. 注册驱动也抽取
    2. 抽取一个方法获取连接对象
        * 需求：不想传递参数（麻烦），还得保证工具类的通用性。
        * 解决：配置文件
            jdbc.properties
                url=
                user=
                password=


    3. 抽取一个方法释放资源

* 代码实现：
    public class JDBCUtils {
    private static String url;
    private static String user;
    private static String password;
    private static String driver;
    /**
     * 文件的读取，只需要读取一次即可拿到这些值。使用静态代码块
     */
    static{
        //读取资源文件，获取值。

        try {
            //1. 创建Properties集合类。
            Properties pro = new Properties();

            //获取src路径下的文件的方式---&gt;ClassLoader 类加载器
            ClassLoader classLoader = JDBCUtils.class.getClassLoader();
            URL res  = classLoader.getResource(&quot;jdbc.properties&quot;);
            String path = res.getPath();
            System.out.println(path);///D:/IdeaProjects/itcast/out/production/day04_jdbc/jdbc.properties
            //2. 加载文件
           // pro.load(new FileReader(&quot;D:\\IdeaProjects\\itcast\\day04_jdbc\\src\\jdbc.properties&quot;));
            pro.load(new FileReader(path));

            //3. 获取数据，赋值
            url = pro.getProperty(&quot;url&quot;);
            user = pro.getProperty(&quot;user&quot;);
            password = pro.getProperty(&quot;password&quot;);
            driver = pro.getProperty(&quot;driver&quot;);
            //4. 注册驱动
            Class.forName(driver);
        } catch (IOException e) {
            e.printStackTrace();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
    }


    /**
     * 获取连接
     * @return 连接对象
     */
    public static Connection getConnection() throws SQLException {

        return DriverManager.getConnection(url, user, password);
    }

    /**
     * 释放资源
     * @param stmt
     * @param conn
     */
    public static void close(Statement stmt,Connection conn){
        if( stmt != null){
            try {
                stmt.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }

        if( conn != null){
            try {
                conn.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }


    /**
     * 释放资源
     * @param stmt
     * @param conn
     */
    public static void close(ResultSet rs,Statement stmt, Connection conn){
        if( rs != null){
            try {
                rs.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }

        if( stmt != null){
            try {
                stmt.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }

        if( conn != null){
            try {
                conn.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }

}

* 练习：
    * 需求：
        1. 通过键盘录入用户名和密码
        2. 判断用户是否登录成功
            * select * from user where username = &quot;&quot; and password = &quot;&quot;;
            * 如果这个sql有查询结果，则成功，反之，则失败

    * 步骤：
        1. 创建数据库表 user
            CREATE TABLE USER(
                id INT PRIMARY KEY AUTO_INCREMENT,
                username VARCHAR(32),
                PASSWORD VARCHAR(32)

            );

            INSERT INTO USER VALUES(NULL,&apos;zhangsan&apos;,&apos;123&apos;);
            INSERT INTO USER VALUES(NULL,&apos;lisi&apos;,&apos;234&apos;);

        2. 代码实现：
            public class JDBCDemo9 {

                public static void main(String[] args) {
                    //1.键盘录入，接受用户名和密码
                    Scanner sc = new Scanner(System.in);
                    System.out.println(&quot;请输入用户名：&quot;);
                    String username = sc.nextLine();
                    System.out.println(&quot;请输入密码：&quot;);
                    String password = sc.nextLine();
                    //2.调用方法
                    boolean flag = new JDBCDemo9().login(username, password);
                    //3.判断结果，输出不同语句
                    if(flag){
                        //登录成功
                        System.out.println(&quot;登录成功！&quot;);
                    }else{
                        System.out.println(&quot;用户名或密码错误！&quot;);
                    }


                }



                /**
                 * 登录方法
                 */
                public boolean login(String username ,String password){
                    if(username == null || password == null){
                        return false;
                    }
                    //连接数据库判断是否登录成功
                    Connection conn = null;
                    Statement stmt =  null;
                    ResultSet rs = null;
                    //1.获取连接
                    try {
                        conn =  JDBCUtils.getConnection();
                        //2.定义sql
                        String sql = &quot;select * from user where username = &apos;&quot;+username+&quot;&apos; and password = &apos;&quot;+password+&quot;&apos; &quot;;
                        //3.获取执行sql的对象
                        stmt = conn.createStatement();
                        //4.执行查询
                        rs = stmt.executeQuery(sql);
                        //5.判断
                       /* if(rs.next()){//如果有下一行，则返回true
                            return true;
                        }else{
                            return false;
                        }*/
                       return rs.next();//如果有下一行，则返回true

                    } catch (SQLException e) {
                        e.printStackTrace();
                    }finally {
                        JDBCUtils.close(rs,stmt,conn);
                    }


                    return false;
                }
            }</code></pre><h2 id="JDBC控制事务："><a href="#JDBC控制事务：" class="headerlink" title="JDBC控制事务："></a>JDBC控制事务：</h2><pre><code>1. 事务：一个包含多个步骤的业务操作。如果这个业务操作被事务管理，则这多个步骤要么同时成功，要么同时失败。
2. 操作：
    1. 开启事务
    2. 提交事务
    3. 回滚事务
3. 使用Connection对象来管理事务
    * 开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务
        * 在执行sql之前开启事务
    * 提交事务：commit() 
        * 当所有sql都执行完提交事务
    * 回滚事务：rollback() 
        * 在catch中回滚事务

4. 代码：
    public class JDBCDemo10 {

        public static void main(String[] args) {
            Connection conn = null;
            PreparedStatement pstmt1 = null;
            PreparedStatement pstmt2 = null;

            try {
                //1.获取连接
                conn = JDBCUtils.getConnection();
                //开启事务
                conn.setAutoCommit(false);

                //2.定义sql
                //2.1 张三 - 500
                String sql1 = &quot;update account set balance = balance - ? where id = ?&quot;;
                //2.2 李四 + 500
                String sql2 = &quot;update account set balance = balance + ? where id = ?&quot;;
                //3.获取执行sql对象
                pstmt1 = conn.prepareStatement(sql1);
                pstmt2 = conn.prepareStatement(sql2);
                //4. 设置参数
                pstmt1.setDouble(1,500);
                pstmt1.setInt(2,1);

                pstmt2.setDouble(1,500);
                pstmt2.setInt(2,2);
                //5.执行sql
                pstmt1.executeUpdate();
                // 手动制造异常
                int i = 3/0;

                pstmt2.executeUpdate();
                //提交事务
                conn.commit();
            } catch (Exception e) {
                //事务回滚
                try {
                    if(conn != null) {
                        conn.rollback();
                    }
                } catch (SQLException e1) {
                    e1.printStackTrace();
                }
                e.printStackTrace();
            }finally {
                JDBCUtils.close(pstmt1,conn);
                JDBCUtils.close(pstmt2,null);
            }


        }

    }</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/10/23/jdbc%E7%AC%94%E8%AE%B0/" data-id="ck2wx3th5000344tf4p734uz2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/10/23/1/" class="article-date">
  <time datetime="2019-10-23T03:36:38.204Z" itemprop="datePublished">2019-10-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/10/23/1/">1</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <pre><code>Java面向对象程序设计</code></pre><p>第一章 复习<br>1.数据类型<br>普通数据：bety、int、short、long、float、docuble、boolean、char<br>引用数据：String和各种对象构成的数据。</p>
<p>第二章 类和对象<br>1.类和对象的概念<br>类：类是有共同特征，共同行为的一类事物的统称。<br>对象：现实世界客观存在的事物都可看作对象。</p>
<p>2.面向过程和面向对象<br>    面向过程：分析出解决问题所需要的步骤，然后把这些步骤一步一步实现。<br>    面向对象：符合人类思考习惯的一种编程思想。这种思想是执行者变为指挥者。提高了代码的复用性及可扩展性。</p>
<p>3.程序的执行过程<br>    从main方法第一行开始，执行到main方法最后一行结束。</p>
<p>4.类的成员（组成部分）<br>    ○1成员变量<br>○2构造方法<br>○3成员方法<br>○4静态方法<br>○5代码块<br>○6静态代码块</p>
<p>5.构造方法<br>    特点：构造方法的名称与类名相同，没有返回值类型，在没有构造方法时，系统会提供一个无参的方法体为空的构造方法。构造方法分为有参和无参两种。<br>    作用：调用带参的构造方法创建对象，在创建对象时执行一些初始化操作，如给成员属性赋初值。<br>    语法：<br>        public 构造方法名(){<br>            方法体;<br>}</p>
<p>6.构造方法的重载<br>    概念及特点：方法名相同，参数个数或参数类型不同，称为构造方法的重载。<br>    作用：通过构造方法的重载来实现多种初始化行为，在创建对象时可以根据需要选择合适的构造方法。</p>
<pre><code>注意：一旦提供了自定义构造方法，系统将不再提供默认构造方法。</code></pre><p>7.方法的重载<br>    概念：一个类中包含两个或以上的方法，它们的方法名相同，参数个数或参数类型不同，则称为方法的重载。<br>    判断依据：<br>        ○1必须在同一个类里<br>        ○2方法名相同<br>        ○3参数个数或参数类型不同<br>        ○4与方法返回值和方法修饰符没有关系</p>
<p>8.static关键字<br>作用：static可用来修饰属性、方法和代码块。<br>    特点：被static修饰的变量和方法称为类变量、类方法。未被static修饰的属性和方法称为实例变量、实例方法。static修饰的变量属于这个类所有，即由这个类创建的所有对象共用一个static变量。<br>注意：类属性、类方法可以通过类名和对象名访问。实例属性、实例方法只能通过对象名访问。类方法只能访问类属性和其它类方法。静态方法中不能使用this和super关键字。</p>
<p>9.this关键字<br>    this代表当前对象，即调用此方法的对象，不能在静态方法中使用。</p>
<p>10.代码块和静态代码块<br>    语法：<br>        //代码块，每次创建对象时被执行<br>        {<br>            System.out.println(“代码块被运行”);<br>        }</p>
<p>//静态代码块，在类加载的时候执行，只执行一次，一般用于类的初始化<br>static{<br>            System.out.println(“静态代码块运行”);<br>        }</p>
<p>第三章 封装<br>1.封装的概念<br>    封装是指将对象的状态信息隐藏在对象内部，不允许外部程序直接访问对象内部信息，而是通过该类所提供的方法实现对内部信息的操作访问。</p>
<pre><code>被private修饰的成员，就被类私有化了，被私有化的成员，不能在类的外部访问，只能在类的内部使用。一般用于封装属性。</code></pre><p>2.封装的步骤<br>1、用private修饰属性（成员变量）<br>2、提供set,get方法，set方法完成对属性的赋值，get方法获取属性的值。<br>3、加入控制语句</p>
<p>3.不同修饰符的访问权限</p>
<p>4.封装的语法格式<br>    public class Person {<br>private String name;            //私有化属性<br>private int age;</p>
<pre><code>public String getName() {        //获取属性的值
    return name;
}
public void setName(String name) {        //对属性赋值
    this.name = name;
}
public int getAge() {
    return age;
}
public void setAge(int age) {
    if(age&gt;0&amp;&amp;age&lt;=150){        //控制语句
      this.age = age;
    }else{
      System.out.println(&quot;年纪不合法&quot;);
    }
}</code></pre><p>}</p>
<p>第四章 继承<br>1.继承的说明<br>    子类继承了父类所有的属性和方法，只不过只能调用父类的非private属性和方法。java中的继承只支持单继承，一个子类只能继承一个父类，但允许多层继承。<br>    优点：提高了代码的重用性，提高了代码的可扩展性。</p>
<p>2.语法<br>    修饰符 class 类名 extends 父类名{<br>        //属性定义<br>        //方法定义<br>}</p>
<p>3.继承中的构造方法<br>    super关键字：<br>作用：1.充当父类的对象，直接调用父类的方法。2.调用父类的构造方法。</p>
<pre><code>super();                //调用父类空的构造方法
super(参数列表);        //调用父类有参的构造方法
super.方法名(参数列表);//调用父类的方法

注意：在创建子类对象的过程中，会先调用父类的构造方法，然后执行子类的构造方法。super关键字不能在静态方法中使用。</code></pre><p>4.重写<br>    概念：子类会继承父类中定义过的方法，但有时需要对继承的方法进行一些修改，即对父类的方法进行重写。</p>
<pre><code>特点：1.重新写从父类继承过来的方法，以满足当前类的需求。2.格式上与父类方法声明保持一致，方法体不一样。</code></pre><p>第五章 多态<br>1.多态的概述<br>    多态可以理解为一个对象可以有多种形态，在调用时根据包含对象的实际类型（即实际的子类对象）来决定调用哪个方法。<br>    优点：可替换性、可扩充性、接口性、灵活性、简化性。</p>
<p>2.多态的必要条件<br>    要有继承，要有重写，父类引用指向子类对象。</p>
<p>3.具体的实现方式<br>    向上转型：<br>        &lt;父类型&gt; &lt;引用变量名&gt; = new &lt;子类型&gt;();</p>
<pre><code>○1父类作为方法的参数：</code></pre><p>如果方法的参数是类类型，那么在调用方法传参时，传的参数就是对应类的对象，或者它子类的对象。<br>如果传入子类的对象，就发生了向上转型。</p>
<pre><code>○2父类作为方法的返回值类型：
    方法的返回值是类类型，那么返回值为对应类的对象或是它子类的对象。</code></pre><p>如果传入它子类的对象，就发生了向上转型</p>
<p>注意：一旦向上转型，那么只能调用到父类声明过的方法，不能调用到自己独有的方法。</p>
<pre><code>向下转型：
    &lt;子类型&gt; &lt;引用变量名&gt; = (&lt;子类型&gt;) new &lt;父类的引用变量&gt;();</code></pre><p>将一个指向子类对象的父类引用赋给一个子类引用，即将父类类型转换为子类类型，称为向下转型，此时必须进行强制类型转换。<br>            将父类转换为子类，然后才可以调用子类特有的方法。</p>
<p>4.instanceof关键字<br>//判断父类型对象是否为当前子类型<br>    if（&lt;父类引用变量&gt; instanceof &lt;子类类型&gt;）{<br>//把父类型引用变量，强制转换为子类类型，并赋值给子类引用变量<br>        &lt;子类类型&gt; &lt;子类引用变量&gt; =（&lt;子类类型&gt;）&lt;父类引用变量&gt;;<br>}</p>
<pre><code>作用：判断对象的类型，向下转型时，判断父类的类型是哪个子类的对象。</code></pre><p>5.try-catch-finally语句<br>    try{<br>        //try里边放的是可能产生异常的代码, try会捕获异常</p>
<p>}catch(){<br>    //catch是处理异常</p>
<p>}finally{<br>    //无论是否发生异常，finally块中的代码总会被执行<br>}</p>
<p>第六章 抽象<br>1.抽象类<br>    概念：被abstract修饰的类，称为抽象类。<br>    特点：无构造方法（没有对象），有抽象方法。<br>    注意：继承抽象类，必须重写抽象类中所有的抽象方法。<br>    语法：<br>public abstract class 类名{</p>
<p>}</p>
<p>2.抽象方法<br>概念：被abstract修饰的方法，称为抽象方法。<br>特点：抽象方法没有方法体，只有方法的声明。<br>语法：<br>public abstract 返回值类型 方法名(参数列表);</p>
<p>3.final修饰符<br>    ○1被final修饰方法不能被重写。<br>○2被final修饰类不能被继承。<br>○3被final修饰的变量是常量，常量值不能被改变，常量用大写字符串表示。</p>
<p>第七章 接口<br>1.接口的定义声明<br>public interface &lt;接口名&gt;{ </p>
<p>}</p>
<p>2.接口的作用<br>    把项目中需要完成的方法，先统一声明一下。</p>
<p>3.接口的实现<br>    注意：接口中只有常量和抽象方法。<br>实现一个接口，必须重写接口中所有的抽象方法。否则必须定义为抽象类。<br>类在继承父类的同时又实现接口时，extends关键字必须位于implements关键字之前。接口不能继承类。<br>一个类只能有一个父类，称为单继承。<br>一个类可以实现多个接口，称为多实现。</p>
<p>接口中的属性都会自动用public static final修饰，可简写为：<br>        常量类型 常量名 = 常量值;</p>
<p>接口中的方法都会自动用public abstract修饰，可简写为：<br>        返回值类型 抽象方法名(参数列表);</p>
<pre><code>修饰符 interface 接口名 extends 父接口1，……{    //接口继承接口
    //常量定义
    //方法定义</code></pre><p>}</p>
<p>修饰符 class 类名 extends 父类名 implements 接口1，……{    //对象实现接口<br>    //类成员<br>}</p>
<p>第八章 集合框架<br>1.集合概述<br>    集合用来存储对象，集合分为两大种，单列集合与双列集合。</p>
<p>2.集合与数组的异同<br>    数组：长度固定，可存储基本数据也可存储对象，必须是相同类型的数据。<br>    集合：集合的长度可变，只能用于存储对象，对象可以是不同类型。</p>
<p>3.单列集合<br>特点：单列集合只能存储一列数据。单列集合的总接口为Collection，它的两个子接口为List接口与Set接口。</p>
<p>List接口：存储一组唯一(不允许重复)、无序的对象。<br>Set接口：存储一组不唯一(允许重复)、有序(以插入次序放置)的对象。</p>
<p>ArrayList集合类实现了List接口，常用的方法有：<br>    add()        添加元素<br>    get()        获得元素<br>    size()        返回元素的个数<br>    remove()    删除元素<br>    HashSet集合类实现了Set接口，可通过add()方法添加对象。</p>
<p>4.双列集合<br>    特点：双列集合能存储一组成对的“键-值对”，可通过key(键)找到value(值)，其中，key不允许重复(如果重复，最后的 “键-值对”将会替换掉原先的“键-值对”)，value允许重复。双列集合总接口为Map。</p>
<pre><code>HashMap集合类实现了Map接口，常用的方法有：</code></pre><p>put()        向集合中添加键值对<br>get(key)    根据键，获取值，不存在则返回null<br>keySet()    返回键的集合<br>values()    返回值的集合<br>size()        返回元素个数<br>remove(key)    删除指定的键的“键-值对”</p>
<p>5.封装类<br>    概念：为了让集合能存储基本数据类型的数据，java把八种基本数据类型封装成类。<br>    自动装箱、自动拆箱：集合存储基本数据类型的值时，会自动把基本数据类型的值，转换为对象，当取出使用的时候，又把对象转换为基本数据类型的值，这就称为自动装箱，自动拆箱。</p>
<pre><code>基本数据类型：    对应的封装类：
int              Integer
byte            Byte
short             Short
long             Long
float             Float
double             Double
char             Character</code></pre><p>boolean            Boolean</p>
<p>6.Iterator迭代器<br>    作用：迭代器用来遍历Set集合类。<br>    语法：<br>//把Set集合中的值，复制到迭代器中<br>        Iterator 迭代器名 = Set集合名.iterator();<br>        //遍历迭代器<br>        while(迭代器名.hasNext()){<br>            System.out.println(迭代器名.next());<br>        }</p>
<pre><code>//hasNext()    判断迭代器中是否有下一个元素，有返回true，无返回false
//next()    获取下一个元素的值</code></pre><p>7.泛型<br>    作用：限制集合只能存储某一个类的对象。<br>    语法：<br>        ArrayList&lt;规定存储对象的类型&gt; 引用集合名 = new ArrayList&lt;…&gt;();<br>        Map&lt;规定键的类型，规定值的类型&gt;</p>
<p>8.加强for循环<br>    作用:用来遍历数组或集合。遍历集合的前提是集合要添加泛型。<br>    语法：<br>        //把被遍历集合或数组中的元素，依次赋值给i<br>        for(被遍历对象存储的类型 i : 被遍历的集合或数组){<br>            System.out.println(i);<br>        }</p>
<p>第九章 文件操作<br>1.File类<br>    File类是IO包中唯一代表磁盘文件本身的对象</p>
<pre><code>//创建文件或文件夹对象,文件可以存在，也可以不存在
File file = new File(&quot;&lt;文件路径&gt;&quot;);

file. createNewFile();    //创建文件
file. mkdir();            //创建文件夹
file. mkdirs();            //一次创建多个文件夹(文件夹目录)
file. isFile();            //判断是否是文件
file. isDirectory();    //判断是否是文件夹
file. exists();            //判断文件是否存在</code></pre><p>2.IO流<br>    IO流的分类：<br>        按方向分：<br>输入流：读取文件中的数据。<br>输出流：向文件中写入数据。<br>按一次操作的字节个数：<br>字节流：一次只能读一个字节，能处理所有类型的数据。<br>字符流：一次可能读多个字节，只能处理字符类型的数据。</p>
<p>3.输出字节流OutputStream类<br>    通常使用它的子类FileOutputStream类</p>
<p>4.输出字符流Writer<br>    通常使用它的子类FileWriter类</p>
<p>5.输入字节流<br>6.输入字符流<br>7.输出字符缓冲流<br>8.输入字符缓冲流</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/10/23/1/" data-id="ck2wx3tgu000044tf5m0y53k9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/10/23/hello-world/" class="article-date">
  <time datetime="2019-10-23T02:45:36.080Z" itemprop="datePublished">2019-10-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/10/23/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/10/23/hello-world/" data-id="ck2wx3th0000144tf4vdu8qb2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/11/13/jsp%E7%AC%AC%E5%9B%9B%E6%AC%A1%E8%AF%BE%E8%AE%B2%E4%B9%89/">jsp第四次课讲义</a>
          </li>
        
          <li>
            <a href="/2019/11/06/%E5%8A%A8%E6%80%81%E7%BD%91%E7%AB%99%E5%BC%80%E5%8F%91%E7%AC%AC%E4%BA%8C%E6%AC%A1%E8%AF%BE%E8%AE%B2%E4%B9%89-1/">动态网站开发第二次课讲义 (1)</a>
          </li>
        
          <li>
            <a href="/2019/11/06/%E5%8A%A8%E6%80%81%E7%BD%91%E7%AB%99%E5%BC%80%E5%8F%91%E7%AC%AC%E4%B8%89%E6%AC%A1%E8%AF%BE%E8%AE%B2%E4%B9%89/">动态网站开发第三次课讲义</a>
          </li>
        
          <li>
            <a href="/2019/10/24/xml%E7%AC%94%E8%AE%B0/">xml笔记</a>
          </li>
        
          <li>
            <a href="/2019/10/23/jdbc%E7%AC%94%E8%AE%B0/">jdbc笔记</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>