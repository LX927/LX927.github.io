<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-xml笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/10/24/xml%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2019-10-24T01:39:31.000Z" itemprop="datePublished">2019-10-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/10/24/xml%E7%AC%94%E8%AE%B0/">xml笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="今日内容"><a href="#今日内容" class="headerlink" title="今日内容"></a>今日内容</h1><pre><code>1. XML
    1. 概念
    2. 语法
    3. 解析</code></pre><h2 id="XML："><a href="#XML：" class="headerlink" title="XML："></a>XML：</h2><pre><code>1. 概念：Extensible Markup Language 可扩展标记语言
    * 可扩展：标签都是自定义的。 &lt;user&gt;  &lt;student&gt;

    * 功能
        * 存储数据
            1. 配置文件
            2. 在网络中传输
    * xml与html的区别
        1. xml标签都是自定义的，html标签是预定义。
        2. xml的语法严格，html语法松散
        3. xml是存储数据的，html是展示数据

    * w3c:万维网联盟

2. 语法：
    * 基本语法：
        1. xml文档的后缀名 .xml
        2. xml第一行必须定义为文档声明
        3. xml文档中有且仅有一个根标签
        4. 属性值必须使用引号(单双都可)引起来
        5. 标签必须正确关闭
        6. xml标签名称区分大小写
    * 快速入门：
        &lt;?xml version=&apos;1.0&apos; ?&gt;
        &lt;users&gt;
            &lt;user id=&apos;1&apos;&gt;
                &lt;name&gt;zhangsan&lt;/name&gt;
                &lt;age&gt;23&lt;/age&gt;
                &lt;gender&gt;male&lt;/gender&gt;
                &lt;br/&gt;
            &lt;/user&gt;

            &lt;user id=&apos;2&apos;&gt;
                &lt;name&gt;lisi&lt;/name&gt;
                &lt;age&gt;24&lt;/age&gt;
                &lt;gender&gt;female&lt;/gender&gt;
            &lt;/user&gt;
        &lt;/users&gt;

    * 组成部分：
        1. 文档声明
            1. 格式：&lt;?xml 属性列表 ?&gt;
            2. 属性列表：
                * version：版本号，必须的属性
                * encoding：编码方式。告知解析引擎当前文档使用的字符集，默认值：ISO-8859-1
                * standalone：是否独立
                    * 取值：
                        * yes：不依赖其他文件
                        * no：依赖其他文件
        2. 指令(了解)：结合css的
            * &lt;?xml-stylesheet type=&quot;text/css&quot; href=&quot;a.css&quot; ?&gt;
        3. 标签：标签名称自定义的
            * 规则：
                * 名称可以包含字母、数字以及其他的字符 
                * 名称不能以数字或者标点符号开始 
                * 名称不能以字母 xml（或者 XML、Xml 等等）开始 
                * 名称不能包含空格 

        4. 属性：
            id属性值唯一
        5. 文本：
            * CDATA区：在该区域中的数据会被原样展示
                * 格式：  &lt;![CDATA[ 数据 ]]&gt;


    * 约束：规定xml文档的书写规则
        * 作为框架的使用者(程序员)：
            1. 能够在xml中引入约束文档
            2. 能够简单的读懂约束文档

        * 分类：
            1. DTD:一种简单的约束技术
            2. Schema:一种复杂的约束技术


        * DTD：
            * 引入dtd文档到xml文档中
                * 内部dtd：将约束规则定义在xml文档中
                * 外部dtd：将约束的规则定义在外部的dtd文件中
                    * 本地：&lt;!DOCTYPE 根标签名 SYSTEM &quot;dtd文件的位置&quot;&gt;
                    * 网络：&lt;!DOCTYPE 根标签名 PUBLIC &quot;dtd文件名字&quot; &quot;dtd文件的位置URL&quot;&gt;


        * Schema:
            * 引入：
                1.填写xml文档的根元素
                2.引入xsi前缀.  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
                3.引入xsd文件命名空间.  xsi:schemaLocation=&quot;http://www.itcast.cn/xml  student.xsd&quot;
                4.为每一个xsd约束声明一个前缀,作为标识  xmlns=&quot;http://www.itcast.cn/xml&quot; 

            &lt;students   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
                xmlns=&quot;http://www.itcast.cn/xml&quot;
                xsi:schemaLocation=&quot;http://www.itcast.cn/xml  student.xsd&quot;&gt;



3. 解析：操作xml文档，将文档中的数据读取到内存中
    * 操作xml文档
        1. 解析(读取)：将文档中的数据读取到内存中
        2. 写入：将内存中的数据保存到xml文档中。持久化的存储

    * 解析xml的方式：
        1. DOM：将标记语言文档一次性加载进内存，在内存中形成一颗dom树
            * 优点：操作方便，可以对文档进行CRUD的所有操作
            * 缺点：占内存
        2. SAX：逐行读取，基于事件驱动的。
            * 优点：不占内存。
            * 缺点：只能读取，不能增删改



    * xml常见的解析器：
        1. JAXP：sun公司提供的解析器，支持dom和sax两种思想
        2. DOM4J：一款非常优秀的解析器
        3. Jsoup：jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。
        4. PULL：Android操作系统内置的解析器，sax方式的。


    * Jsoup：jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。
        * 快速入门：
            * 步骤：
                1. 导入jar包
                2. 获取Document对象
                3. 获取对应的标签Element对象
                4. 获取数据

        * 代码：
             //2.1获取student.xml的path
            String path = JsoupDemo1.class.getClassLoader().getResource(&quot;student.xml&quot;).getPath();
            //2.2解析xml文档，加载文档进内存，获取dom树---&gt;Document
            Document document = Jsoup.parse(new File(path), &quot;utf-8&quot;);
            //3.获取元素对象 Element
            Elements elements = document.getElementsByTag(&quot;name&quot;);

            System.out.println(elements.size());
            //3.1获取第一个name的Element对象
            Element element = elements.get(0);
            //3.2获取数据
            String name = element.text();
            System.out.println(name);

    * 对象的使用：
        1. Jsoup：工具类，可以解析html或xml文档，返回Document
            * parse：解析html或xml文档，返回Document
                * parse​(File in, String charsetName)：解析xml或html文件的。
                * parse​(String html)：解析xml或html字符串
                * parse​(URL url, int timeoutMillis)：通过网络路径获取指定的html或xml的文档对象
        2. Document：文档对象。代表内存中的dom树
            * 获取Element对象
                * getElementById​(String id)：根据id属性值获取唯一的element对象
                * getElementsByTag​(String tagName)：根据标签名称获取元素对象集合
                * getElementsByAttribute​(String key)：根据属性名称获取元素对象集合
                * getElementsByAttributeValue​(String key, String value)：根据对应的属性名和属性值获取元素对象集合
        3. Elements：元素Element对象的集合。可以当做 ArrayList&lt;Element&gt;来使用
        4. Element：元素对象
            1. 获取子元素对象
                * getElementById​(String id)：根据id属性值获取唯一的element对象
                * getElementsByTag​(String tagName)：根据标签名称获取元素对象集合
                * getElementsByAttribute​(String key)：根据属性名称获取元素对象集合
                * getElementsByAttributeValue​(String key, String value)：根据对应的属性名和属性值获取元素对象集合

            2. 获取属性值
                * String attr(String key)：根据属性名称获取属性值
            3. 获取文本内容
                * String text():获取文本内容
                * String html():获取标签体的所有内容(包括字标签的字符串内容)
        5. Node：节点对象
            * 是Document和Element的父类


    * 快捷查询方式：
        1. selector:选择器
            * 使用的方法：Elements    select​(String cssQuery)
                * 语法：参考Selector类中定义的语法
        2. XPath：XPath即为XML路径语言，它是一种用来确定XML（标准通用标记语言的子集）文档中某部分位置的语言
            * 使用Jsoup的Xpath需要额外导入jar包。
            * 查询w3cshool参考手册，使用xpath的语法完成查询
            * 代码：
                //1.获取student.xml的path
                String path = JsoupDemo6.class.getClassLoader().getResource(&quot;student.xml&quot;).getPath();
                //2.获取Document对象
                Document document = Jsoup.parse(new File(path), &quot;utf-8&quot;);

                //3.根据document对象，创建JXDocument对象
                JXDocument jxDocument = new JXDocument(document);

                //4.结合xpath语法查询
                //4.1查询所有student标签
                List&lt;JXNode&gt; jxNodes = jxDocument.selN(&quot;//student&quot;);
                for (JXNode jxNode : jxNodes) {
                    System.out.println(jxNode);
                }

                System.out.println(&quot;--------------------&quot;);

                //4.2查询所有student标签下的name标签
                List&lt;JXNode&gt; jxNodes2 = jxDocument.selN(&quot;//student/name&quot;);
                for (JXNode jxNode : jxNodes2) {
                    System.out.println(jxNode);
                }

                System.out.println(&quot;--------------------&quot;);

                //4.3查询student标签下带有id属性的name标签
                List&lt;JXNode&gt; jxNodes3 = jxDocument.selN(&quot;//student/name[@id]&quot;);
                for (JXNode jxNode : jxNodes3) {
                    System.out.println(jxNode);
                }
                System.out.println(&quot;--------------------&quot;);
                //4.4查询student标签下带有id属性的name标签 并且id属性值为itcast

                List&lt;JXNode&gt; jxNodes4 = jxDocument.selN(&quot;//student/name[@id=&apos;itcast&apos;]&quot;);
                for (JXNode jxNode : jxNodes4) {
                    System.out.println(jxNode);
                }</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/10/24/xml%E7%AC%94%E8%AE%B0/" data-id="ck241ha9z0003nwtfcrwr832u" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-jdbc笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/10/23/jdbc%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2019-10-23T11:17:47.000Z" itemprop="datePublished">2019-10-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/10/23/jdbc%E7%AC%94%E8%AE%B0/">jdbc笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="今日内容"><a href="#今日内容" class="headerlink" title="今日内容"></a>今日内容</h1><pre><code>1. JDBC基本概念
2. 快速入门
3. 对JDBC中各个接口和类详解</code></pre><h2 id="JDBC："><a href="#JDBC：" class="headerlink" title="JDBC："></a>JDBC：</h2><pre><code>1. 概念：Java DataBase Connectivity  Java 数据库连接， Java语言操作数据库
    * JDBC本质：其实是官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类。

2. 快速入门：
    * 步骤：
        1. 导入驱动jar包 mysql-connector-java-5.1.37-bin.jar
            1.复制mysql-connector-java-5.1.37-bin.jar到项目的libs目录下
            2.右键--&gt;Add As Library
        2. 注册驱动
        3. 获取数据库连接对象 Connection
        4. 定义sql
        5. 获取执行sql语句的对象 Statement
        6. 执行sql，接受返回结果
        7. 处理结果
        8. 释放资源

    * 代码实现：
          //1. 导入驱动jar包
        //2.注册驱动
        Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
        //3.获取数据库连接对象
        Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/db3&quot;, &quot;root&quot;, &quot;root&quot;);
        //4.定义sql语句
        String sql = &quot;update account set balance = 500 where id = 1&quot;;
        //5.获取执行sql的对象 Statement
        Statement stmt = conn.createStatement();
        //6.执行sql
        int count = stmt.executeUpdate(sql);
        //7.处理结果
        System.out.println(count);
        //8.释放资源
        stmt.close();
        conn.close();

3. 详解各个对象：
    1. DriverManager：驱动管理对象
        * 功能：
            1. 注册驱动：告诉程序该使用哪一个数据库驱动jar
                static void registerDriver(Driver driver) :注册与给定的驱动程序 DriverManager 。 
                写代码使用：  Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
                通过查看源码发现：在com.mysql.jdbc.Driver类中存在静态代码块
                 static {
                        try {
                            java.sql.DriverManager.registerDriver(new Driver());
                        } catch (SQLException E) {
                            throw new RuntimeException(&quot;Can&apos;t register driver!&quot;);
                        }
                    }

                注意：mysql5之后的驱动jar包可以省略注册驱动的步骤。
            2. 获取数据库连接：
                * 方法：static Connection getConnection(String url, String user, String password) 
                * 参数：
                    * url：指定连接的路径
                        * 语法：jdbc:mysql://ip地址(域名):端口号/数据库名称
                        * 例子：jdbc:mysql://localhost:3306/db3
                        * 细节：如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则url可以简写为：jdbc:mysql:///数据库名称
                    * user：用户名
                    * password：密码 
    2. Connection：数据库连接对象
        1. 功能：
            1. 获取执行sql 的对象
                * Statement createStatement()
                * PreparedStatement prepareStatement(String sql)  
            2. 管理事务：
                * 开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务
                * 提交事务：commit() 
                * 回滚事务：rollback() 
    3. Statement：执行sql的对象
        1. 执行sql
            1. boolean execute(String sql) ：可以执行任意的sql 了解 
            2. int executeUpdate(String sql) ：执行DML（insert、update、delete）语句、DDL(create，alter、drop)语句
                * 返回值：影响的行数，可以通过这个影响的行数判断DML语句是否执行成功 返回值&gt;0的则执行成功，反之，则失败。
            3. ResultSet executeQuery(String sql)  ：执行DQL（select)语句
        2. 练习：
            1. account表 添加一条记录
            2. account表 修改记录
            3. account表 删除一条记录

            代码：
                Statement stmt = null;
                Connection conn = null;
                try {
                    //1. 注册驱动
                    Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
                    //2. 定义sql
                    String sql = &quot;insert into account values(null,&apos;王五&apos;,3000)&quot;;
                    //3.获取Connection对象
                    conn = DriverManager.getConnection(&quot;jdbc:mysql:///db3&quot;, &quot;root&quot;, &quot;root&quot;);
                    //4.获取执行sql的对象 Statement
                    stmt = conn.createStatement();
                    //5.执行sql
                    int count = stmt.executeUpdate(sql);//影响的行数
                    //6.处理结果
                    System.out.println(count);
                    if(count &gt; 0){
                        System.out.println(&quot;添加成功！&quot;);
                    }else{
                        System.out.println(&quot;添加失败！&quot;);
                    }

                } catch (ClassNotFoundException e) {
                    e.printStackTrace();
                } catch (SQLException e) {
                    e.printStackTrace();
                }finally {
                    //stmt.close();
                    //7. 释放资源
                    //避免空指针异常
                    if(stmt != null){
                        try {
                            stmt.close();
                        } catch (SQLException e) {
                            e.printStackTrace();
                        }
                    }

                    if(conn != null){
                        try {
                            conn.close();
                        } catch (SQLException e) {
                            e.printStackTrace();
                        }
                    }
                }

    4. ResultSet：结果集对象,封装查询结果
        * boolean next(): 游标向下移动一行，判断当前行是否是最后一行末尾(是否有数据)，如果是，则返回false，如果不是则返回true
        * getXxx(参数):获取数据
            * Xxx：代表数据类型   如： int getInt() ,    String getString()
            * 参数：
                1. int：代表列的编号,从1开始   如： getString(1)
                2. String：代表列名称。 如： getDouble(&quot;balance&quot;)

        * 注意：
            * 使用步骤：
                1. 游标向下移动一行
                2. 判断是否有数据
                3. 获取数据

               //循环判断游标是否是最后一行末尾。
                while(rs.next()){
                    //获取数据
                    //6.2 获取数据
                    int id = rs.getInt(1);
                    String name = rs.getString(&quot;name&quot;);
                    double balance = rs.getDouble(3);

                    System.out.println(id + &quot;---&quot; + name + &quot;---&quot; + balance);
                }

        * 练习：
            * 定义一个方法，查询emp表的数据将其封装为对象，然后装载集合，返回。
                1. 定义Emp类
                2. 定义方法 public List&lt;Emp&gt; findAll(){}
                3. 实现方法 select * from emp;

    5. PreparedStatement：执行sql的对象
        1. SQL注入问题：在拼接sql时，有一些sql的特殊关键字参与字符串的拼接。会造成安全性问题
            1. 输入用户随便，输入密码：a&apos; or &apos;a&apos; = &apos;a
            2. sql：select * from user where username = &apos;fhdsjkf&apos; and password = &apos;a&apos; or &apos;a&apos; = &apos;a&apos; 

        2. 解决sql注入问题：使用PreparedStatement对象来解决
        3. 预编译的SQL：参数使用?作为占位符
        4. 步骤：
            1. 导入驱动jar包 mysql-connector-java-5.1.37-bin.jar
            2. 注册驱动
            3. 获取数据库连接对象 Connection
            4. 定义sql
                * 注意：sql的参数使用？作为占位符。 如：select * from user where username = ? and password = ?;
            5. 获取执行sql语句的对象 PreparedStatement  Connection.prepareStatement(String sql) 
            6. 给？赋值：
                * 方法： setXxx(参数1,参数2)
                    * 参数1：？的位置编号 从1 开始
                    * 参数2：？的值
            7. 执行sql，接受返回结果，不需要传递sql语句
            8. 处理结果
            9. 释放资源

        5. 注意：后期都会使用PreparedStatement来完成增删改查的所有操作
            1. 可以防止SQL注入
            2. 效率更高</code></pre><h2 id="抽取JDBC工具类-：-JDBCUtils"><a href="#抽取JDBC工具类-：-JDBCUtils" class="headerlink" title="抽取JDBC工具类 ： JDBCUtils"></a>抽取JDBC工具类 ： JDBCUtils</h2><pre><code>* 目的：简化书写
* 分析：
    1. 注册驱动也抽取
    2. 抽取一个方法获取连接对象
        * 需求：不想传递参数（麻烦），还得保证工具类的通用性。
        * 解决：配置文件
            jdbc.properties
                url=
                user=
                password=


    3. 抽取一个方法释放资源

* 代码实现：
    public class JDBCUtils {
    private static String url;
    private static String user;
    private static String password;
    private static String driver;
    /**
     * 文件的读取，只需要读取一次即可拿到这些值。使用静态代码块
     */
    static{
        //读取资源文件，获取值。

        try {
            //1. 创建Properties集合类。
            Properties pro = new Properties();

            //获取src路径下的文件的方式---&gt;ClassLoader 类加载器
            ClassLoader classLoader = JDBCUtils.class.getClassLoader();
            URL res  = classLoader.getResource(&quot;jdbc.properties&quot;);
            String path = res.getPath();
            System.out.println(path);///D:/IdeaProjects/itcast/out/production/day04_jdbc/jdbc.properties
            //2. 加载文件
           // pro.load(new FileReader(&quot;D:\\IdeaProjects\\itcast\\day04_jdbc\\src\\jdbc.properties&quot;));
            pro.load(new FileReader(path));

            //3. 获取数据，赋值
            url = pro.getProperty(&quot;url&quot;);
            user = pro.getProperty(&quot;user&quot;);
            password = pro.getProperty(&quot;password&quot;);
            driver = pro.getProperty(&quot;driver&quot;);
            //4. 注册驱动
            Class.forName(driver);
        } catch (IOException e) {
            e.printStackTrace();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
    }


    /**
     * 获取连接
     * @return 连接对象
     */
    public static Connection getConnection() throws SQLException {

        return DriverManager.getConnection(url, user, password);
    }

    /**
     * 释放资源
     * @param stmt
     * @param conn
     */
    public static void close(Statement stmt,Connection conn){
        if( stmt != null){
            try {
                stmt.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }

        if( conn != null){
            try {
                conn.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }


    /**
     * 释放资源
     * @param stmt
     * @param conn
     */
    public static void close(ResultSet rs,Statement stmt, Connection conn){
        if( rs != null){
            try {
                rs.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }

        if( stmt != null){
            try {
                stmt.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }

        if( conn != null){
            try {
                conn.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }

}

* 练习：
    * 需求：
        1. 通过键盘录入用户名和密码
        2. 判断用户是否登录成功
            * select * from user where username = &quot;&quot; and password = &quot;&quot;;
            * 如果这个sql有查询结果，则成功，反之，则失败

    * 步骤：
        1. 创建数据库表 user
            CREATE TABLE USER(
                id INT PRIMARY KEY AUTO_INCREMENT,
                username VARCHAR(32),
                PASSWORD VARCHAR(32)

            );

            INSERT INTO USER VALUES(NULL,&apos;zhangsan&apos;,&apos;123&apos;);
            INSERT INTO USER VALUES(NULL,&apos;lisi&apos;,&apos;234&apos;);

        2. 代码实现：
            public class JDBCDemo9 {

                public static void main(String[] args) {
                    //1.键盘录入，接受用户名和密码
                    Scanner sc = new Scanner(System.in);
                    System.out.println(&quot;请输入用户名：&quot;);
                    String username = sc.nextLine();
                    System.out.println(&quot;请输入密码：&quot;);
                    String password = sc.nextLine();
                    //2.调用方法
                    boolean flag = new JDBCDemo9().login(username, password);
                    //3.判断结果，输出不同语句
                    if(flag){
                        //登录成功
                        System.out.println(&quot;登录成功！&quot;);
                    }else{
                        System.out.println(&quot;用户名或密码错误！&quot;);
                    }


                }



                /**
                 * 登录方法
                 */
                public boolean login(String username ,String password){
                    if(username == null || password == null){
                        return false;
                    }
                    //连接数据库判断是否登录成功
                    Connection conn = null;
                    Statement stmt =  null;
                    ResultSet rs = null;
                    //1.获取连接
                    try {
                        conn =  JDBCUtils.getConnection();
                        //2.定义sql
                        String sql = &quot;select * from user where username = &apos;&quot;+username+&quot;&apos; and password = &apos;&quot;+password+&quot;&apos; &quot;;
                        //3.获取执行sql的对象
                        stmt = conn.createStatement();
                        //4.执行查询
                        rs = stmt.executeQuery(sql);
                        //5.判断
                       /* if(rs.next()){//如果有下一行，则返回true
                            return true;
                        }else{
                            return false;
                        }*/
                       return rs.next();//如果有下一行，则返回true

                    } catch (SQLException e) {
                        e.printStackTrace();
                    }finally {
                        JDBCUtils.close(rs,stmt,conn);
                    }


                    return false;
                }
            }</code></pre><h2 id="JDBC控制事务："><a href="#JDBC控制事务：" class="headerlink" title="JDBC控制事务："></a>JDBC控制事务：</h2><pre><code>1. 事务：一个包含多个步骤的业务操作。如果这个业务操作被事务管理，则这多个步骤要么同时成功，要么同时失败。
2. 操作：
    1. 开启事务
    2. 提交事务
    3. 回滚事务
3. 使用Connection对象来管理事务
    * 开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务
        * 在执行sql之前开启事务
    * 提交事务：commit() 
        * 当所有sql都执行完提交事务
    * 回滚事务：rollback() 
        * 在catch中回滚事务

4. 代码：
    public class JDBCDemo10 {

        public static void main(String[] args) {
            Connection conn = null;
            PreparedStatement pstmt1 = null;
            PreparedStatement pstmt2 = null;

            try {
                //1.获取连接
                conn = JDBCUtils.getConnection();
                //开启事务
                conn.setAutoCommit(false);

                //2.定义sql
                //2.1 张三 - 500
                String sql1 = &quot;update account set balance = balance - ? where id = ?&quot;;
                //2.2 李四 + 500
                String sql2 = &quot;update account set balance = balance + ? where id = ?&quot;;
                //3.获取执行sql对象
                pstmt1 = conn.prepareStatement(sql1);
                pstmt2 = conn.prepareStatement(sql2);
                //4. 设置参数
                pstmt1.setDouble(1,500);
                pstmt1.setInt(2,1);

                pstmt2.setDouble(1,500);
                pstmt2.setInt(2,2);
                //5.执行sql
                pstmt1.executeUpdate();
                // 手动制造异常
                int i = 3/0;

                pstmt2.executeUpdate();
                //提交事务
                conn.commit();
            } catch (Exception e) {
                //事务回滚
                try {
                    if(conn != null) {
                        conn.rollback();
                    }
                } catch (SQLException e1) {
                    e1.printStackTrace();
                }
                e.printStackTrace();
            }finally {
                JDBCUtils.close(pstmt1,conn);
                JDBCUtils.close(pstmt2,null);
            }


        }

    }</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/10/23/jdbc%E7%AC%94%E8%AE%B0/" data-id="ck241ha9l0000nwtf7b885ch3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/10/23/1/" class="article-date">
  <time datetime="2019-10-23T03:36:38.204Z" itemprop="datePublished">2019-10-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/10/23/1/">1</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <pre><code>Java面向对象程序设计</code></pre><p>第一章 复习<br>1.数据类型<br>普通数据：bety、int、short、long、float、docuble、boolean、char<br>引用数据：String和各种对象构成的数据。</p>
<p>第二章 类和对象<br>1.类和对象的概念<br>类：类是有共同特征，共同行为的一类事物的统称。<br>对象：现实世界客观存在的事物都可看作对象。</p>
<p>2.面向过程和面向对象<br>    面向过程：分析出解决问题所需要的步骤，然后把这些步骤一步一步实现。<br>    面向对象：符合人类思考习惯的一种编程思想。这种思想是执行者变为指挥者。提高了代码的复用性及可扩展性。</p>
<p>3.程序的执行过程<br>    从main方法第一行开始，执行到main方法最后一行结束。</p>
<p>4.类的成员（组成部分）<br>    ○1成员变量<br>○2构造方法<br>○3成员方法<br>○4静态方法<br>○5代码块<br>○6静态代码块</p>
<p>5.构造方法<br>    特点：构造方法的名称与类名相同，没有返回值类型，在没有构造方法时，系统会提供一个无参的方法体为空的构造方法。构造方法分为有参和无参两种。<br>    作用：调用带参的构造方法创建对象，在创建对象时执行一些初始化操作，如给成员属性赋初值。<br>    语法：<br>        public 构造方法名(){<br>            方法体;<br>}</p>
<p>6.构造方法的重载<br>    概念及特点：方法名相同，参数个数或参数类型不同，称为构造方法的重载。<br>    作用：通过构造方法的重载来实现多种初始化行为，在创建对象时可以根据需要选择合适的构造方法。</p>
<pre><code>注意：一旦提供了自定义构造方法，系统将不再提供默认构造方法。</code></pre><p>7.方法的重载<br>    概念：一个类中包含两个或以上的方法，它们的方法名相同，参数个数或参数类型不同，则称为方法的重载。<br>    判断依据：<br>        ○1必须在同一个类里<br>        ○2方法名相同<br>        ○3参数个数或参数类型不同<br>        ○4与方法返回值和方法修饰符没有关系</p>
<p>8.static关键字<br>作用：static可用来修饰属性、方法和代码块。<br>    特点：被static修饰的变量和方法称为类变量、类方法。未被static修饰的属性和方法称为实例变量、实例方法。static修饰的变量属于这个类所有，即由这个类创建的所有对象共用一个static变量。<br>注意：类属性、类方法可以通过类名和对象名访问。实例属性、实例方法只能通过对象名访问。类方法只能访问类属性和其它类方法。静态方法中不能使用this和super关键字。</p>
<p>9.this关键字<br>    this代表当前对象，即调用此方法的对象，不能在静态方法中使用。</p>
<p>10.代码块和静态代码块<br>    语法：<br>        //代码块，每次创建对象时被执行<br>        {<br>            System.out.println(“代码块被运行”);<br>        }</p>
<p>//静态代码块，在类加载的时候执行，只执行一次，一般用于类的初始化<br>static{<br>            System.out.println(“静态代码块运行”);<br>        }</p>
<p>第三章 封装<br>1.封装的概念<br>    封装是指将对象的状态信息隐藏在对象内部，不允许外部程序直接访问对象内部信息，而是通过该类所提供的方法实现对内部信息的操作访问。</p>
<pre><code>被private修饰的成员，就被类私有化了，被私有化的成员，不能在类的外部访问，只能在类的内部使用。一般用于封装属性。</code></pre><p>2.封装的步骤<br>1、用private修饰属性（成员变量）<br>2、提供set,get方法，set方法完成对属性的赋值，get方法获取属性的值。<br>3、加入控制语句</p>
<p>3.不同修饰符的访问权限</p>
<p>4.封装的语法格式<br>    public class Person {<br>private String name;            //私有化属性<br>private int age;</p>
<pre><code>public String getName() {        //获取属性的值
    return name;
}
public void setName(String name) {        //对属性赋值
    this.name = name;
}
public int getAge() {
    return age;
}
public void setAge(int age) {
    if(age&gt;0&amp;&amp;age&lt;=150){        //控制语句
      this.age = age;
    }else{
      System.out.println(&quot;年纪不合法&quot;);
    }
}</code></pre><p>}</p>
<p>第四章 继承<br>1.继承的说明<br>    子类继承了父类所有的属性和方法，只不过只能调用父类的非private属性和方法。java中的继承只支持单继承，一个子类只能继承一个父类，但允许多层继承。<br>    优点：提高了代码的重用性，提高了代码的可扩展性。</p>
<p>2.语法<br>    修饰符 class 类名 extends 父类名{<br>        //属性定义<br>        //方法定义<br>}</p>
<p>3.继承中的构造方法<br>    super关键字：<br>作用：1.充当父类的对象，直接调用父类的方法。2.调用父类的构造方法。</p>
<pre><code>super();                //调用父类空的构造方法
super(参数列表);        //调用父类有参的构造方法
super.方法名(参数列表);//调用父类的方法

注意：在创建子类对象的过程中，会先调用父类的构造方法，然后执行子类的构造方法。super关键字不能在静态方法中使用。</code></pre><p>4.重写<br>    概念：子类会继承父类中定义过的方法，但有时需要对继承的方法进行一些修改，即对父类的方法进行重写。</p>
<pre><code>特点：1.重新写从父类继承过来的方法，以满足当前类的需求。2.格式上与父类方法声明保持一致，方法体不一样。</code></pre><p>第五章 多态<br>1.多态的概述<br>    多态可以理解为一个对象可以有多种形态，在调用时根据包含对象的实际类型（即实际的子类对象）来决定调用哪个方法。<br>    优点：可替换性、可扩充性、接口性、灵活性、简化性。</p>
<p>2.多态的必要条件<br>    要有继承，要有重写，父类引用指向子类对象。</p>
<p>3.具体的实现方式<br>    向上转型：<br>        &lt;父类型&gt; &lt;引用变量名&gt; = new &lt;子类型&gt;();</p>
<pre><code>○1父类作为方法的参数：</code></pre><p>如果方法的参数是类类型，那么在调用方法传参时，传的参数就是对应类的对象，或者它子类的对象。<br>如果传入子类的对象，就发生了向上转型。</p>
<pre><code>○2父类作为方法的返回值类型：
    方法的返回值是类类型，那么返回值为对应类的对象或是它子类的对象。</code></pre><p>如果传入它子类的对象，就发生了向上转型</p>
<p>注意：一旦向上转型，那么只能调用到父类声明过的方法，不能调用到自己独有的方法。</p>
<pre><code>向下转型：
    &lt;子类型&gt; &lt;引用变量名&gt; = (&lt;子类型&gt;) new &lt;父类的引用变量&gt;();</code></pre><p>将一个指向子类对象的父类引用赋给一个子类引用，即将父类类型转换为子类类型，称为向下转型，此时必须进行强制类型转换。<br>            将父类转换为子类，然后才可以调用子类特有的方法。</p>
<p>4.instanceof关键字<br>//判断父类型对象是否为当前子类型<br>    if（&lt;父类引用变量&gt; instanceof &lt;子类类型&gt;）{<br>//把父类型引用变量，强制转换为子类类型，并赋值给子类引用变量<br>        &lt;子类类型&gt; &lt;子类引用变量&gt; =（&lt;子类类型&gt;）&lt;父类引用变量&gt;;<br>}</p>
<pre><code>作用：判断对象的类型，向下转型时，判断父类的类型是哪个子类的对象。</code></pre><p>5.try-catch-finally语句<br>    try{<br>        //try里边放的是可能产生异常的代码, try会捕获异常</p>
<p>}catch(){<br>    //catch是处理异常</p>
<p>}finally{<br>    //无论是否发生异常，finally块中的代码总会被执行<br>}</p>
<p>第六章 抽象<br>1.抽象类<br>    概念：被abstract修饰的类，称为抽象类。<br>    特点：无构造方法（没有对象），有抽象方法。<br>    注意：继承抽象类，必须重写抽象类中所有的抽象方法。<br>    语法：<br>public abstract class 类名{</p>
<p>}</p>
<p>2.抽象方法<br>概念：被abstract修饰的方法，称为抽象方法。<br>特点：抽象方法没有方法体，只有方法的声明。<br>语法：<br>public abstract 返回值类型 方法名(参数列表);</p>
<p>3.final修饰符<br>    ○1被final修饰方法不能被重写。<br>○2被final修饰类不能被继承。<br>○3被final修饰的变量是常量，常量值不能被改变，常量用大写字符串表示。</p>
<p>第七章 接口<br>1.接口的定义声明<br>public interface &lt;接口名&gt;{ </p>
<p>}</p>
<p>2.接口的作用<br>    把项目中需要完成的方法，先统一声明一下。</p>
<p>3.接口的实现<br>    注意：接口中只有常量和抽象方法。<br>实现一个接口，必须重写接口中所有的抽象方法。否则必须定义为抽象类。<br>类在继承父类的同时又实现接口时，extends关键字必须位于implements关键字之前。接口不能继承类。<br>一个类只能有一个父类，称为单继承。<br>一个类可以实现多个接口，称为多实现。</p>
<p>接口中的属性都会自动用public static final修饰，可简写为：<br>        常量类型 常量名 = 常量值;</p>
<p>接口中的方法都会自动用public abstract修饰，可简写为：<br>        返回值类型 抽象方法名(参数列表);</p>
<pre><code>修饰符 interface 接口名 extends 父接口1，……{    //接口继承接口
    //常量定义
    //方法定义</code></pre><p>}</p>
<p>修饰符 class 类名 extends 父类名 implements 接口1，……{    //对象实现接口<br>    //类成员<br>}</p>
<p>第八章 集合框架<br>1.集合概述<br>    集合用来存储对象，集合分为两大种，单列集合与双列集合。</p>
<p>2.集合与数组的异同<br>    数组：长度固定，可存储基本数据也可存储对象，必须是相同类型的数据。<br>    集合：集合的长度可变，只能用于存储对象，对象可以是不同类型。</p>
<p>3.单列集合<br>特点：单列集合只能存储一列数据。单列集合的总接口为Collection，它的两个子接口为List接口与Set接口。</p>
<p>List接口：存储一组唯一(不允许重复)、无序的对象。<br>Set接口：存储一组不唯一(允许重复)、有序(以插入次序放置)的对象。</p>
<p>ArrayList集合类实现了List接口，常用的方法有：<br>    add()        添加元素<br>    get()        获得元素<br>    size()        返回元素的个数<br>    remove()    删除元素<br>    HashSet集合类实现了Set接口，可通过add()方法添加对象。</p>
<p>4.双列集合<br>    特点：双列集合能存储一组成对的“键-值对”，可通过key(键)找到value(值)，其中，key不允许重复(如果重复，最后的 “键-值对”将会替换掉原先的“键-值对”)，value允许重复。双列集合总接口为Map。</p>
<pre><code>HashMap集合类实现了Map接口，常用的方法有：</code></pre><p>put()        向集合中添加键值对<br>get(key)    根据键，获取值，不存在则返回null<br>keySet()    返回键的集合<br>values()    返回值的集合<br>size()        返回元素个数<br>remove(key)    删除指定的键的“键-值对”</p>
<p>5.封装类<br>    概念：为了让集合能存储基本数据类型的数据，java把八种基本数据类型封装成类。<br>    自动装箱、自动拆箱：集合存储基本数据类型的值时，会自动把基本数据类型的值，转换为对象，当取出使用的时候，又把对象转换为基本数据类型的值，这就称为自动装箱，自动拆箱。</p>
<pre><code>基本数据类型：    对应的封装类：
int              Integer
byte            Byte
short             Short
long             Long
float             Float
double             Double
char             Character</code></pre><p>boolean            Boolean</p>
<p>6.Iterator迭代器<br>    作用：迭代器用来遍历Set集合类。<br>    语法：<br>//把Set集合中的值，复制到迭代器中<br>        Iterator 迭代器名 = Set集合名.iterator();<br>        //遍历迭代器<br>        while(迭代器名.hasNext()){<br>            System.out.println(迭代器名.next());<br>        }</p>
<pre><code>//hasNext()    判断迭代器中是否有下一个元素，有返回true，无返回false
//next()    获取下一个元素的值</code></pre><p>7.泛型<br>    作用：限制集合只能存储某一个类的对象。<br>    语法：<br>        ArrayList&lt;规定存储对象的类型&gt; 引用集合名 = new ArrayList&lt;…&gt;();<br>        Map&lt;规定键的类型，规定值的类型&gt;</p>
<p>8.加强for循环<br>    作用:用来遍历数组或集合。遍历集合的前提是集合要添加泛型。<br>    语法：<br>        //把被遍历集合或数组中的元素，依次赋值给i<br>        for(被遍历对象存储的类型 i : 被遍历的集合或数组){<br>            System.out.println(i);<br>        }</p>
<p>第九章 文件操作<br>1.File类<br>    File类是IO包中唯一代表磁盘文件本身的对象</p>
<pre><code>//创建文件或文件夹对象,文件可以存在，也可以不存在
File file = new File(&quot;&lt;文件路径&gt;&quot;);

file. createNewFile();    //创建文件
file. mkdir();            //创建文件夹
file. mkdirs();            //一次创建多个文件夹(文件夹目录)
file. isFile();            //判断是否是文件
file. isDirectory();    //判断是否是文件夹
file. exists();            //判断文件是否存在</code></pre><p>2.IO流<br>    IO流的分类：<br>        按方向分：<br>输入流：读取文件中的数据。<br>输出流：向文件中写入数据。<br>按一次操作的字节个数：<br>字节流：一次只能读一个字节，能处理所有类型的数据。<br>字符流：一次可能读多个字节，只能处理字符类型的数据。</p>
<p>3.输出字节流OutputStream类<br>    通常使用它的子类FileOutputStream类</p>
<p>4.输出字符流Writer<br>    通常使用它的子类FileWriter类</p>
<p>5.输入字节流<br>6.输入字符流<br>7.输出字符缓冲流<br>8.输入字符缓冲流</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/10/23/1/" data-id="ck241ha9r0002nwtfelwt1jvz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/10/23/hello-world/" class="article-date">
  <time datetime="2019-10-23T02:45:36.080Z" itemprop="datePublished">2019-10-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/10/23/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/10/23/hello-world/" data-id="ck241ha9p0001nwtffy5w2l51" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/10/24/xml%E7%AC%94%E8%AE%B0/">xml笔记</a>
          </li>
        
          <li>
            <a href="/2019/10/23/jdbc%E7%AC%94%E8%AE%B0/">jdbc笔记</a>
          </li>
        
          <li>
            <a href="/2019/10/23/1/">1</a>
          </li>
        
          <li>
            <a href="/2019/10/23/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>